<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModelingToolkit IR · ModelingToolkit.jl</title><link rel="canonical" href="https://mtk.sciml.ai/stable/IR/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ModelingToolkit.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/symbolic_functions/">Symbolic Calculations and Building Fast Parallel Functions</a></li><li><a class="tocitem" href="../tutorials/ode_modeling/">Component-Based Modeling with Ordinary Differential Equations</a></li><li><a class="tocitem" href="../tutorials/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../tutorials/nonlinear/">Solving Nonlinear Systems with NLsolve</a></li><li><a class="tocitem" href="../tutorials/modelingtoolkitize/">Symbolic Extensions to ODEProblem via Modelingtoolkize</a></li><li><a class="tocitem" href="../tutorials/auto_parallel/">Automated Sparse Parallelism of ODEs via Tracing</a></li><li><a class="tocitem" href="../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../systems/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../systems/ControlSystem/">ControlSystem</a></li><li><a class="tocitem" href="../systems/ReactionSystem/">ReactionSystem</a></li><li><a class="tocitem" href="../systems/PDESystem/">PDESystem</a></li><li><a class="tocitem" href="../systems/DependencyGraphs/">Dependency Graphs</a></li></ul></li><li><a class="tocitem" href="../comparison/">Comparison Against SymPy</a></li><li><a class="tocitem" href="../highlevel/">High Level API</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li class="is-active"><a class="tocitem" href>ModelingToolkit IR</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ModelingToolkit IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModelingToolkit IR</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/IR.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelingToolkit-IR-1"><a class="docs-heading-anchor" href="#ModelingToolkit-IR-1">ModelingToolkit IR</a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-IR-1" title="Permalink"></a></h1><p>ModelingToolkit IR mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the <code>Sym</code> type, which defines a symbolic variable. Registered (mathematical) functions on <code>Sym</code>s (or <code>Term</code>s) return <code>Term</code>s.  For example, <code>op1 = x+y</code> is one <code>Term</code> and <code>op2 = 2z</code> is another, and so <code>op1*op2</code> is another <code>Term</code>. Then, at the top, an <code>Equation</code>, normally written as <code>op1 ~ op2</code>, defines the symbolic equality between two operations.</p><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Sym</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Term</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Equation" href="#ModelingToolkit.Equation"><code>ModelingToolkit.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Equation</code></pre><p>An equality relationship between two expressions.</p><p><strong>Fields</strong></p><ul><li><p><code>lhs</code></p><p>The expression on the left-hand side of the equation.</p></li><li><p><code>rhs</code></p><p>The expression on the right-hand side of the equation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/equations.jl#L1">source</a></section></article><h3 id="A-note-about-functions-restricted-to-Numbers-1"><a class="docs-heading-anchor" href="#A-note-about-functions-restricted-to-Numbers-1">A note about functions restricted to <code>Number</code>s</a><a class="docs-heading-anchor-permalink" href="#A-note-about-functions-restricted-to-Numbers-1" title="Permalink"></a></h3><p><code>Sym</code> and <code>Term</code> objects are NOT subtypes of <code>Number</code>. ModelingToolkit provides a simple wrapper type called <code>Num</code> which is a subtype of <code>Real</code>. <code>Num</code> wraps either a Sym or a Term or any other object, defines the same set of operations as symbolic expressions and forwards those to the values it wraps. You can use <code>ModelingToolkit.value</code> function to unwrap a <code>Num</code>.</p><p>By default, the <code>@variables</code> and <code>@parameters</code> functions return Num-wrapped objects so as to allow calling functions which are restricted to <code>Number</code> or <code>Real</code>.</p><h3 id="Function-Registration-1"><a class="docs-heading-anchor" href="#Function-Registration-1">Function Registration</a><a class="docs-heading-anchor-permalink" href="#Function-Registration-1" title="Permalink"></a></h3><p>The ModelingToolkit graph only allowed for registered Julia functions for the operations. All other functions are automatically traced down to registered functions. By default, ModelingToolkit.jl pre-registers the common functions utilized in <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils.jl</a> and pre-defines their derivatives. However, the user can utilize the <code>@register</code> macro to add their function to allowed functions of the computation graph.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>@register</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Derivatives-and-Differentials-1"><a class="docs-heading-anchor" href="#Derivatives-and-Differentials-1">Derivatives and Differentials</a><a class="docs-heading-anchor-permalink" href="#Derivatives-and-Differentials-1" title="Permalink"></a></h3><p>A <code>Differential(op)</code> is a partial derivative with respect to <code>op</code>, which can then be applied to some other operations. For example, <code>D=Differential(t)</code> is what would commonly be referred to as <code>d/dt</code>, which can then be applied to other operations using its function call, so <code>D(x+y)</code> is <code>d(x+y)/dt</code>.</p><p>By default, the derivatives are left unexpanded to capture the symbolic representation of the differential equation. If the user would like to expand out all of the differentials, the <code>expand_derivatives</code> function eliminates all of the differentials down to basic one-variable expressions.</p><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.derivative" href="#ModelingToolkit.derivative"><code>ModelingToolkit.derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derivative(O, idx)
</code></pre><p>Calculate the derivative of the op <code>O</code> with respect to its argument with index <code>idx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; ModelingToolkit.derivative(sin(x), 1)
cos(x())</code></pre><p>Note that the function does not recurse into the operation&#39;s arguments, i.e., the chain rule is not applied:</p><pre><code class="language-julia-repl">julia&gt; myop = sin(x) * y^2
sin(x()) * y() ^ 2

julia&gt; typeof(myop.op)  # Op is multiplication function
typeof(*)

julia&gt; ModelingToolkit.derivative(myop, 1)  # wrt. sin(x)
y() ^ 2

julia&gt; ModelingToolkit.derivative(myop, 2)  # wrt. y^2
sin(x())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/differentials.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Differential" href="#ModelingToolkit.Differential"><code>ModelingToolkit.Differential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Differential &lt;: Function</code></pre><p>Represents a differential operator.</p><p><strong>Fields</strong></p><ul><li><p><code>x</code></p><p>The variable or expression to differentiate with respect to.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; D = Differential(x)
(D&#39;~x())

julia&gt; D(y)  # Differentiate y wrt. x
(D&#39;~x())(y())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/differentials.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.expand_derivatives" href="#ModelingToolkit.expand_derivatives"><code>ModelingToolkit.expand_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_derivatives(O)
expand_derivatives(O, simplify; occurances)
</code></pre><p>TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/differentials.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.jacobian" href="#ModelingToolkit.jacobian"><code>ModelingToolkit.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(ops::AbstractVector, vars::AbstractVector; simplify = true)</code></pre><p>A helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/direct.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.gradient" href="#ModelingToolkit.gradient"><code>ModelingToolkit.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gradient(O, vars::AbstractVector; simplify = true)</code></pre><p>A helper function for computing the gradient of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/direct.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.hessian" href="#ModelingToolkit.hessian"><code>ModelingToolkit.hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hessian(O, vars::AbstractVector; simplify = true)</code></pre><p>A helper function for computing the Hessian of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/direct.jl#L92-L99">source</a></section></article><p>For jacobians which are sparse, use the <code>sparsejacobian</code> function. For hessians which are sparse, use the <code>sparsehessian</code> function.</p><h3 id="Adding-Derivatives-1"><a class="docs-heading-anchor" href="#Adding-Derivatives-1">Adding Derivatives</a><a class="docs-heading-anchor-permalink" href="#Adding-Derivatives-1" title="Permalink"></a></h3><p>There is a large amount of derivatives pre-defined by <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a>.</p><pre><code class="language-julia">f(x,y,z) = x^2 + sin(x+y) - z</code></pre><p>automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.</p><p>However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:</p><pre><code class="language-julia"># `N` arguments are accepted by the relevant method of `my_function`
ModelingToolkit.derivative(::typeof(my_function), args::NTuple{N,Any}, ::Val{i})</code></pre><p>where <code>i</code> means that it&#39;s the derivative with respect to the <code>i</code>th argument. <code>args</code> is the array of arguments, so, for example, if your function is <code>f(x,t)</code>, then <code>args = [x,t]</code>. You should return an <code>Term</code> for the derivative of your function.</p><p>For example, <code>sin(t)</code>&#39;s derivative (by <code>t</code>) is given by the following:</p><pre><code class="language-julia">ModelingToolkit.derivative(::typeof(sin), args::NTuple{1,Any}, ::Val{1}) = cos(args[1])</code></pre><h3 id="IR-Manipulation-1"><a class="docs-heading-anchor" href="#IR-Manipulation-1">IR Manipulation</a><a class="docs-heading-anchor-permalink" href="#IR-Manipulation-1" title="Permalink"></a></h3><p>ModelingToolkit.jl provides functionality for easily manipulating expressions. Most of the functionality comes by the expression objects obeying the standard mathematical semantics. For example, if one has <code>A</code> a matrix of symbolic expressions wrapped in <code>Num</code>, then <code>A^2</code> calculates the expressions for the squared matrix.  In that sense, it is encouraged that one uses standard Julia for performing a lot of the manipulation on the IR, as, for example, calculating the sparse form of the matrix via <code>sparse(A)</code> is valid, legible, and easily understandable to all Julia programmers.</p><p>Other additional manipulation functions are given below.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplify_constants</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.rename" href="#ModelingToolkit.rename"><code>ModelingToolkit.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename(x::Variable, name::Symbol) -&gt; Sym{Any}
</code></pre><p>Renames the variable <code>x</code> to have <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/variables.jl#L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.get_variables" href="#ModelingToolkit.get_variables"><code>ModelingToolkit.get_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><p>get_variables(O)</p><p>Returns the variables in the expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/f7f378ca4fd4424140b674e7190c650e398c1f6d/src/utils.jl#L55-L59">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>substitute_expr!</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../build_function/">« Function Building and Compilation (build_function)</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 10 November 2020 04:31">Tuesday 10 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
