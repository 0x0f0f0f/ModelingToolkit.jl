<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModelingToolkit IR · ModelingToolkit.jl</title><link rel="canonical" href="https://docs.sciml.ai/stable/IR/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ModelingToolkit.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../highlevel/">High Level API</a></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../systems/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../systems/ReactionSystem/">ReactionSystem</a></li><li><a class="tocitem" href="../systems/PDESystem/">PDESystem</a></li></ul></li><li class="is-active"><a class="tocitem" href>ModelingToolkit IR</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ModelingToolkit IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModelingToolkit IR</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/IR.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelingToolkit-IR-1"><a class="docs-heading-anchor" href="#ModelingToolkit-IR-1">ModelingToolkit IR</a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-IR-1" title="Permalink"></a></h1><p>ModelingToolkit IR, which falls under the <code>Expression</code> abstract type, mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the <code>Variable</code> type which defines a symbolic variable. These variables are combined using <code>Operation</code>s, which are registered functions applied to the various variables. These <code>Operation</code>s then perform automatic tracing, so normal mathematical functions applied to an <code>Operation</code> generate a new <code>Operation</code>. For example, <code>op1 = x+y</code> is one <code>Operation</code> and <code>op2 = 2z</code> is another, and so <code>op1*op2</code> is another <code>Operation</code>. Then at the top, an <code>Equation</code>, normally written as <code>op1 ~ op2</code>, defines the symbolic equality between two operations.</p><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Expression" href="#ModelingToolkit.Expression"><code>ModelingToolkit.Expression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Expression &lt;: Number</code></pre><p>Base type for a symbolic expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/ModelingToolkit.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Variable" href="#ModelingToolkit.Variable"><code>ModelingToolkit.Variable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Variable{T} &lt;: Function</code></pre><p>A named variable which represents a numerical value. The variable is uniquely identified by its <code>name</code>, and all variables with the same <code>name</code> are treated as equal.</p><p><strong>Fields</strong></p><ul><li><p><code>name</code></p><p>The variable&#39;s unique name.</p></li></ul><p>For example, the following code defines an independent variable <code>t</code>, a parameter <code>α</code>, a function parameter <code>σ</code>, a variable <code>x</code> which depends on <code>t</code>, a variable <code>y</code> with no dependents, a variable <code>z</code> which depends on <code>t</code>, <code>α</code>, and <code>x(t)</code> and a parameters <code>β₁</code> and <code>β₂</code>.</p><pre><code class="language-julia">t = Variable(:t)()  # independent variables are treated as known
α = Variable(:α)()  # parameters are known
σ = Variable(:σ)    # left uncalled, since it is used as a function
w = Variable(:w)   # unknown, left uncalled
x = Variable(:x)(t)  # unknown, depends on `t`
y = Variable(:y)()   # unknown, no dependents
z = Variable(:z)(t, α, x)  # unknown, multiple arguments
β₁ = Variable(:β, 1)() # with index 1
β₂ = Variable(:β, 2)() # with index 2

expr = β₁ * x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/variables.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Constant" href="#ModelingToolkit.Constant"><code>ModelingToolkit.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Constant &lt;: Expression</code></pre><p>An expression which wraps a constant numerical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/variables.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Operation" href="#ModelingToolkit.Operation"><code>ModelingToolkit.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Operation &lt;: Expression</code></pre><p>An expression representing the application of a function to symbolic arguments.</p><p><strong>Fields</strong></p><ul><li><p><code>op</code></p><p>The function to be applied.</p></li><li><p><code>args</code></p><p>The arguments the function is applied to.</p></li></ul><p><strong>Examples</strong></p><p>Operations can be built by application of most built-in mathematical functions to other <a href="#ModelingToolkit.Expression"><code>Expression</code></a> instances:</p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; op1 = sin(x)
sin(x())

julia&gt; typeof(op1.op)
typeof(sin)

julia&gt; op1.args
1-element Array{Expression,1}:
 x()

julia&gt; op2 = x + y
x() + y()

julia&gt; typeof(op2.op)
typeof(+)

julia&gt; op2.args
2-element Array{Expression,1}:
 x()
 y()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/operations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Equation" href="#ModelingToolkit.Equation"><code>ModelingToolkit.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Equation</code></pre><p>An equality relationship between two expressions.</p><p><strong>Fields</strong></p><ul><li><p><code>lhs</code></p><p>The expression on the left hand side of the equation.</p></li><li><p><code>rhs</code></p><p>The expression on the right hand side of the equation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/equations.jl#L1">source</a></section></article><h3 id="Function-Registration-1"><a class="docs-heading-anchor" href="#Function-Registration-1">Function Registration</a><a class="docs-heading-anchor-permalink" href="#Function-Registration-1" title="Permalink"></a></h3><p>The ModelingToolkit graph only allowed for registered Julia functions for the operations. All other functions are automatically traced down to registred functions. By default, ModelingToolkit.jl pre-registers the common functions utilized in the AD package ruleset <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a> and pre-defines their derivatives. However, the user can utilize the <code>@register</code> macro to add their function to allowed functions of the computation graph.</p><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.@register" href="#ModelingToolkit.@register"><code>ModelingToolkit.@register</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Registers a function call as a primative for the <code>Operation</code> graph of the ModelingToolkit IR. Example:</p><pre><code class="language-julia">@register f(x,y)</code></pre><p>registers <code>f</code> as a possible two-argument function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/function_registration.jl#L2">source</a></section></article><h3 id="Derivatives-and-Differentials-1"><a class="docs-heading-anchor" href="#Derivatives-and-Differentials-1">Derivatives and Differentials</a><a class="docs-heading-anchor-permalink" href="#Derivatives-and-Differentials-1" title="Permalink"></a></h3><p>A <code>Differential(op)</code> is a partial derivative with respect to the operation <code>op</code> which can then be applied to some other operations. For example <code>D=Differential(t)</code> is what would commonly be referred to as <code>d/dt</code>, which can then be applied to other operations using its function call, so <code>D(x+y)</code> is <code>d(x+y)/dt</code>.</p><p>By default, the derivatives are left unexpanded to capture the symbolic representation of the differential equation. If the user would like to expand out all of the differentials, the <code>expand_derivatives</code> function eliminates all of the differentials down to basic one-variable expressions.</p><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.Differential" href="#ModelingToolkit.Differential"><code>ModelingToolkit.Differential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Differential &lt;: Function</code></pre><p>Represents a differential operator.</p><p><strong>Fields</strong></p><ul><li><p><code>x</code></p><p>The variable or expression to differentiate with respect to.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; D = Differential(x)
(D&#39;~x())

julia&gt; D(y)  # Differentiate y wrt. x
(D&#39;~x())(y())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/differentials.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.expand_derivatives" href="#ModelingToolkit.expand_derivatives"><code>ModelingToolkit.expand_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_derivatives(O)
</code></pre><p>TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/differentials.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.derivative" href="#ModelingToolkit.derivative"><code>ModelingToolkit.derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derivative(O, idx)
</code></pre><p>Calculate the derivative of the op <code>O</code> with respect to its argument with index <code>idx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; ModelingToolkit.derivative(sin(x), 1)
cos(x())</code></pre><p>Note that the function does not recurse into the operation&#39;s arguments, i.e. the chain rule is not applied:</p><pre><code class="language-julia-repl">julia&gt; myop = sin(x) * y^2
sin(x()) * y() ^ 2

julia&gt; typeof(myop.op)  # Op is multiplication function
typeof(*)

julia&gt; ModelingToolkit.derivative(myop, 1)  # wrt. sin(x)
y() ^ 2

julia&gt; ModelingToolkit.derivative(myop, 2)  # wrt. y^2
sin(x())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/differentials.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.gradient" href="#ModelingToolkit.gradient"><code>ModelingToolkit.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gradient(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the gradient of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/direct.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.jacobian" href="#ModelingToolkit.jacobian"><code>ModelingToolkit.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/direct.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.hessian" href="#ModelingToolkit.hessian"><code>ModelingToolkit.hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hessian(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Hessian of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/direct.jl#L27-L34">source</a></section></article><p>Note that generation of sparse matrices simply follows from the Julian semantics imbued on the IR, so <code>sparse(jac)</code> changes a dense Jacobian to a sparse Jacobian matrix.</p><h3 id="Adding-Derivatives-1"><a class="docs-heading-anchor" href="#Adding-Derivatives-1">Adding Derivatives</a><a class="docs-heading-anchor-permalink" href="#Adding-Derivatives-1" title="Permalink"></a></h3><p>There is a large amount of derivatives pre-defined by <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a>. Note that <code>Expression</code> types are defined as <code>&lt;:Real</code>, and thus any functions which allow the use of real numbers can automatically be traced by the derivative mechanism. Thus for example:</p><pre><code class="language-julia">f(x,y,z) = x^2 + sin(x+y) - z</code></pre><p>automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.</p><p>However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:</p><pre><code class="language-julia"># `N` arguments are accepted by the relevant method of `my_function`
ModelingToolkit.derivative(::typeof(my_function), args::NTuple{N,Any}, ::Val{i})</code></pre><p>where <code>i</code> means that it&#39;s the derivative of the <code>i</code>th argument. <code>args</code> is the array of arguments, so for example if your function is <code>f(x,t)</code> then <code>args = [x,t]</code>. You should return an <code>Operation</code> for the derivative of your function.</p><p>For example, <code>sin(t)</code>&#39;s derivative (by <code>t</code>) is given by the following:</p><pre><code class="language-julia">ModelingToolkit.derivative(::typeof(sin), args::NTuple{1,Any}, ::Val{1}) = cos(args[1])</code></pre><h3 id="IR-Manipulation-1"><a class="docs-heading-anchor" href="#IR-Manipulation-1">IR Manipulation</a><a class="docs-heading-anchor-permalink" href="#IR-Manipulation-1" title="Permalink"></a></h3><p>ModelingToolkit.jl provides functionality for easily manipulating <code>Expression</code> types. Most of the functionality comes by the <code>Expression</code> type obeying the standard mathematical semantics. For example, if one has <code>A</code> a matrix of <code>Expression</code>, then <code>A^2</code> calculates the <code>Expression</code>s for the squared matrix. In that sense, it is encouraged that one uses standard Julia for performing a lot of the manipulation on the IR, as for example calculating the sparse form of the matrix via <code>sparse(A)</code> is valid, legible, and easily understandable to all Julia programmers.</p><p>Other additional manipulation functions are given below.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplify_constants</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.rename" href="#ModelingToolkit.rename"><code>ModelingToolkit.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename(x::Variable, name::Symbol) -&gt; Variable{_A} where _A
</code></pre><p>Renames the variable <code>x</code> to have <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/variables.jl#L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.get_variables" href="#ModelingToolkit.get_variables"><code>ModelingToolkit.get_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><p>get_variables(O::Operation)</p><p>Returns the variables in the Operation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/utils.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.substitute_expr!" href="#ModelingToolkit.substitute_expr!"><code>ModelingToolkit.substitute_expr!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>substitute_expr!(expr::Operation, s::Pair{Operation, Operation})</p><p>Performs the substitution <code>Operation =&gt; Operation</code> on the <code>expr</code> Operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/utils.jl#L102-L106">source</a></section></article><h3 id="Expression-Generation-and-build_function-1"><a class="docs-heading-anchor" href="#Expression-Generation-and-build_function-1">Expression Generation and <code>build_function</code></a><a class="docs-heading-anchor-permalink" href="#Expression-Generation-and-build_function-1" title="Permalink"></a></h3><p>At any time, Julia expressions can be generated from ModelingToolkit IR by using <code>convert(Expr,x)</code>. This performs some cleaning to return an expression without extraneous pieces that commonly matches expressions one would write in functions like those for differential equation solvers and optimization libraries.</p><p>Additionally, the core compilation process of ModelingToolkit IR is <code>build_function</code>. <code>build_function</code> takes an operation or an <code>AbstractArray</code> of operations and generates a compile-able version of the model for numerical solvers.</p><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.build_function" href="#ModelingToolkit.build_function"><code>ModelingToolkit.build_function</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>build_function</code></p><p>Generates a numerically-usable function from a ModelingToolkit <code>Expression</code>. If the <code>Expression</code> is an <code>Operation</code>, the generated function is a function with a scalar output, otherwise if it&#39;s an <code>AbstractArray{Operation}</code> the output is two functions, one for out-of-place AbstractArray output and a second which is a mutating function. The outputted functions match the given argument order, i.e. f(u,p,args...) for the out-of-place and scalar functions and <code>f!(du,u,p,args..)</code> for the in-place version.</p><pre><code class="language-julia">build_function(ex, args...;
               conv = simplified_expr, expression = Val{true},
               checkbounds = false, constructor=nothing,
               linenumbers = false, target = JuliaTarget())</code></pre><p>Arguments:</p><ul><li><code>ex</code>: The <code>Expression</code> to compile</li><li><code>vs</code>: The variables of the expression</li><li><code>ps</code>: The parameters of the expression</li><li><code>args</code>: Extra arguments to the function</li><li><code>conv</code>: The conversion function of the Operation to Expr. By default this uses the <code>simplified_expr</code> function utilized in <code>convert(Expr,x)</code>.</li><li><code>expression</code>: Whether to generate code or whether to generate the compiled form. By default, <code>expression = Val{true}</code>, which means that the code for the function is returned. If <code>Val{false}</code>, then the returned value is a compiled Julia function which utilizes GeneralizedGenerated.jl in order to world-age free.</li></ul><p>Keyword Arguments:</p><ul><li><code>checkbounds</code>: For whether to enable bounds checking inside of the generated function. Defaults to false, meaning that <code>@inbounds</code> is applied.</li><li><code>constructor</code>: Allows for an arbitrary constructor function to be passed in for handling expressions of &quot;weird&quot; types. Defaults to nothing.</li><li><code>linenumbers</code>: Determines whether the generated function expression retains the line numbers. Defaults to true.</li><li><code>target</code>: The output target of the compilation process. Possible options are:<ul><li><code>JuliaTarget</code>: Generates a Julia function</li><li><code>CTarget</code>: Generates a C function</li><li><code>StanTarget</code>: Generates a function for compiling with the Stan probabilistic programming language</li><li><code>MATLABTarget</code>: Generates an anonymous function for use in MATLAB and Octave environments</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/94a5f4eaa89067cf90c194e1005da97afb355fc9/src/build_function.jl#L7-L54">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../systems/PDESystem/">« PDESystem</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 3 May 2020 19:15">Sunday 3 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
