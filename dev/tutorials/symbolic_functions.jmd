# Symbolic Calculations and Building Fast Functions

ModelingToolkit.jl is first and foremost a symbolic modeling language.
The way to define symbolic variables is via the `@variables` macro:

```julia
@variables x y
```

After defining variables as symbolic, symbolic expressions can be
generated by utilizing Julia expressions. For example:

```julia
z = x^2 + y
```

Here, `z` is the symbolic expression for "square `x` and add `y`". To
make an array of symbolic expressions, simply make an array of
symbolic expressions:

```julia
A = [x^2+y 0 2x
     0     0 2y
     y^2+x 0 0]

3×3 Array{Expression,2}:
  x ^ 2 + y  Constant(0)           2x
Constant(0)  Constant(0)           2y
  y ^ 2 + x  Constant(0)  Constant(0)
```

Normal Julia functions work on ModelingToolkit expressions, so if we
want to create the sparse version of `A` we would just call `sparse`:

```julia
using SparseArrays
spA = sparse(A)

3×3 SparseMatrixCSC{Expression,Int64} with 4 stored entries:
  [1, 1]  =  x ^ 2 + y
  [3, 1]  =  y ^ 2 + x
  [1, 3]  =  2x
  [2, 3]  =  2y
```

We can thus use normal Julia functions as generators for sparse
expressions. For example, here we will define

```julia
function f(u)
  [u[1]-u[3],u[1]^2-u[2],u[3]+u[2]]
end
f([x,y,z]) # Recall that z = x^2 + y

3-element Array{Operation,1}:
 x - (x ^ 2 + y)
       x ^ 2 - y
 (x ^ 2 + y) + y
```

Or we can build array variables and use these to trace:

```julia
@variables u[1:3]
f(u)

3-element Array{Operation,1}:
     u₁ - u₃
 u₁ ^ 2 - u₂
     u₃ + u₂
```

## Building Functions

The function for building functions is the aptly-named `build_function`.
The first argument is the symbolic expression or the array of symbolic
expressions to compile, and the trailing arguments are the arguments
for the function. For example:

```julia
to_compute = [x^2 + y, y^2 + x]
f_expr = build_function(to_compute,[x,y])
```

gives back two codes. The first is a function `f([x,y])` that computes
and builds an output vector `[x^2 + y, y^2 + x]`. Because this tool
was made to be used by all the cool kids writing fast Julia codes, it
is specialized to Julia and supports features like StaticArrays. For
example:

```julia
myf = eval(f_expr[1])
myf(SA[2.0,3.0])

2-element SArray{Tuple{2},Float64,1,2} with indices SOneTo(2):
  7.0
 11.0
```

The second function is an in-place non-allocating mutating function
which mutates its first value:

```julia
f_expr[2]

:((var"##MTIIPVar#292", var"##MTKArg#290")->begin
          @inbounds begin
                  let (x, y) = (var"##MTKArg#290"[1], var"##MTKArg#290"[2])
                      var"##MTIIPVar#292"[1] = (getproperty(Base, :+))(x ^ 2, y)
                      var"##MTIIPVar#292"[2] = (getproperty(Base, :+))(y ^ 2, x)
                  end
              end
          nothing
      end)
```

Thus we'd use it like the following:

```julia
myf! = eval(f_expr[2])
out = zeros(2)
myf!(out,[2.0,3.0])
out

2-element Array{Float64,1}:
  7.0
 11.0
```

Note that if we need to avoid `eval`, for example to avoid world-age
issues, one could do `expression = Val{false}`:

```julia
build_function(to_compute,[x,y],expression=Val{false})
```

which will use [GeneralizedGenerated.jl](https://github.com/thautwarm/GeneralizedGenerated.jl)
to build Julia functions which avoid world-age issues.
