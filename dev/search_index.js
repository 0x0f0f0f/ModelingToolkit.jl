var documenterSearchIndex = {"docs":
[{"location":"systems/OptimizationSystem/#OptimizationSystem-1","page":"OptimizationSystem","title":"OptimizationSystem","text":"","category":"section"},{"location":"systems/OptimizationSystem/#System-Constructors-1","page":"OptimizationSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationSystem","category":"page"},{"location":"systems/OptimizationSystem/#ModelingToolkit.OptimizationSystem","page":"OptimizationSystem","title":"ModelingToolkit.OptimizationSystem","text":"struct OptimizationSystem <: ModelingToolkit.AbstractSystem\n\nA scalar equation for optimization.\n\nFields\n\nop\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\nop = σ*(y-x) + x*(ρ-z)-y + x*y - β*z\nos = OptimizationSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/OptimizationSystem/#Composition-and-Accessor-Functions-1","page":"OptimizationSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"sys.eqs or equations(sys): The equation to be minimized.\nsys.states or states(sys): The set of states for the optimization.\nsys.parameters or parameters(sys): The parameters for the optimization.","category":"page"},{"location":"systems/OptimizationSystem/#Transformations-1","page":"OptimizationSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/OptimizationSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"OptimizationSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"calculate_gradient\r\ncalculate_hessian\r\ngenerate_gradient\r\ngenerate_hessian","category":"page"},{"location":"systems/OptimizationSystem/#Problem-Constructors-1","page":"OptimizationSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationProblem","category":"page"},{"location":"systems/OptimizationSystem/#DiffEqBase.OptimizationProblem","page":"OptimizationSystem","title":"DiffEqBase.OptimizationProblem","text":"function DiffEqBase.OptimizationProblem{iip}(sys::OptimizationSystem,\n                                          parammap=DiffEqBase.NullParameters();\n                                          u0=nothing, lb=nothing, ub=nothing,\n                                          hes = false, sparse = false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an OptimizationProblem from an OptimizationSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#ReactionSystem-1","page":"ReactionSystem","title":"ReactionSystem","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"A ReactionSystem represents a system of chemical reactions. Conversions are provided to generate corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models. As a simple example, the code below creates a SIR model, and solves the corresponding ODE, SDE and jump process models.","category":"page"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"using ModelingToolkit, OrdinaryDiffEq, StochasticDiffEq, DiffEqJump\r\n@parameters β γ t\r\n@variables S(t) I(t) R(t)\r\n\r\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\r\n       Reaction(γ, [I], [R])]\r\nrs  = ReactionSystem(rxs, t, [S,I,R], [β,γ])\r\n\r\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\r\nparammap = [β => 1/10000, γ => 0.01]\r\ntspan    = (0.0, 250.0)\r\n\r\n# solve as ODEs\r\nodesys = convert(ODESystem, rs)\r\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\r\nsol = solve(oprob, Tsit5())\r\n\r\n# solve as SDEs\r\nsdesys = convert(SDESystem, rs)\r\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\r\nsol = solve(sprob, EM(), dt=.01)\r\n\r\n# solve as jump process\r\njumpsys = convert(JumpSystem, rs)\r\nu₀map    = [S => 999, I => 1, R => 0]\r\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\r\njprob = JumpProblem(jumpsys, dprob, Direct())\r\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"systems/ReactionSystem/#System-Constructors-1","page":"ReactionSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Reaction\r\nReactionSystem","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.Reaction","page":"ReactionSystem","title":"ModelingToolkit.Reaction","text":"struct Reaction{S<:Variable, T<:Number}\n\nOne chemical reaction.\n\nFields\n\nrate\nThe rate function (excluding mass action terms).\nsubstrates\nReaction substrates.\nproducts\nReaction products.\nsubstoich\nThe stoichiometric coefficients of the reactants.\nprodstoich\nThe stoichiometric coefficients of the products.\nnetstoich\nThe net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate\nfalse (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nExamples\n\nusing ModelingToolkit\n@parameters t k[1:20]\n@variables A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products.  In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients  are one.\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#ModelingToolkit.ReactionSystem","page":"ReactionSystem","title":"ModelingToolkit.ReactionSystem","text":"struct ReactionSystem <: ModelingToolkit.AbstractSystem\n\nA system of chemical reactions.\n\nFields\n\neqs\nThe reactions defining the system.\niv\nIndependent variable (usually time).\nstates\nDependent (state) variables representing amount of each species.\nps\nParameter variables.\nname\nThe name of the system\nsystems\nsystems: The internal systems\n\nExample\n\nContinuing from the example in the Reaction definition:\n\nrs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#Composition-and-Accessor-Functions-1","page":"ReactionSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"sys.eqs or equations(sys): The reactions that define the system.\nsys.states or states(sys): The set of chemical species in the system.\nsys.parameters or parameters(sys): The parameters of the system.\nsys.iv or independent_variable(sys): The independent variable of the reaction system, usually time.","category":"page"},{"location":"systems/ReactionSystem/#Query-Functions-1","page":"ReactionSystem","title":"Query Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"ismassaction","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.ismassaction","page":"ReactionSystem","title":"ModelingToolkit.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate), \n                              haveivdep = any(var -> isequal(rs.iv,convert(Variable,var)), rxvars))    \n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend  explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, the Variables the rx depends on.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on the independent variable. \n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#Transformations-1","page":"ReactionSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Base.convert","category":"page"},{"location":"systems/ReactionSystem/#Base.convert","page":"ReactionSystem","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ODESystem.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to a SDESystem.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to a JumpSystem.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#The-AbstractSystem-Interface-1","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"","category":"section"},{"location":"systems/AbstractSystem/#Overview-1","page":"The AbstractSystem Interface","title":"Overview","text":"","category":"section"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The AbstractSystem interface is the core of the system level of ModelingToolkit.jl. It establishes a common set of functionality that is used between systems from ODEs and chemical reactions, allowing users to have a common framework for model manipulation and compilation.","category":"page"},{"location":"systems/AbstractSystem/#Composition-and-Accessor-Functions-1","page":"The AbstractSystem Interface","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Each AbstractSystem has lists of variables in context, such as distinguishing parameters vs states. In addition, an AbstractSystem also can hold other AbstractSystem types. Direct accessing of the values, such as sys.states, gives the immediate list, while the accessor functions states(sys) gives the total set which includes that of all systems held inside.","category":"page"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The values which are common to all AbstractSystems are:","category":"page"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"sys.eqs or equations(sys): The equations that define the system.\nsys.states or states(sys): The set of states in the system.\nsys.parameters or parameters(sys): The parameters of the system.\nsys.systems: The subsystems of the system.","category":"page"},{"location":"systems/AbstractSystem/#Transformations-1","page":"The AbstractSystem Interface","title":"Transformations","text":"","category":"section"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Transformations are functions which send a valid AbstractSystem definition to another AbstractSystem. These are passes like optimizations (ex: Block-Lower Triangle transformations) or changes to the representation which allow for alternative numerical methods to be utilized on the model (ex: DAE index reduction).","category":"page"},{"location":"systems/AbstractSystem/#Function-Calculation-and-Generation-1","page":"The AbstractSystem Interface","title":"Function Calculation and Generation","text":"","category":"section"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The calculation and generation functions allow for calculating additional quantities to enhance the numerical methods applied to the resulting system. The calculations, like calculate_jacobian, generate ModelingToolkit IR for the Jacobian of the system, while the generations, like generate_jacobian, generate compiled output for the numerical solvers by applying build_function to the generated code. Additionally, many systems have function type outputs which cobble together the generation functionality for a system, for example ODEFunction can be used to generate a DifferentialEquations-based ODEFunction with compiled version of the ODE itself, the Jacobian, the mass matrix, etc.","category":"page"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Below are the possible calculation and generation functions:","category":"page"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"calculate_tgrad\r\ncalculate_gradient\r\ncalculate_jacobian\r\ncalculate_factorized_W\r\ncalculate_hessian\r\ngenerate_tgrad\r\ngenerate_gradient\r\ngenerate_jacobian\r\ngenerate_factorized_W\r\ngenerate_hessian","category":"page"},{"location":"systems/AbstractSystem/#ModelingToolkit.calculate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_tgrad","text":"calculate_tgrad(sys::AbstractSystem)\n\nCalculate the time gradient of a system.\n\nReturns a vector of Expression instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.calculate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_gradient","text":"calculate_gradient(sys::AbstractSystem)\n\nCalculate the gradient of a scalar system.\n\nReturns a vector of Expression instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.calculate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_jacobian","text":"calculate_jacobian(sys::AbstractSystem)\n\nCalculate the jacobian matrix of a system.\n\nReturns a matrix of Expression instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.calculate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_factorized_W","text":"calculate_factorized_W(sys::AbstractSystem)\n\nCalculate the factorized W-matrix of a system.\n\nReturns a matrix of Expression instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.calculate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_hessian","text":"calculate_hessian(sys::AbstractSystem)\n\nCalculate the hessian matrix of a scalar system.\n\nReturns a matrix of Expression instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.generate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_tgrad","text":"generate_tgrad(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the time gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.generate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_gradient","text":"generate_gradient(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.generate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_jacobian","text":"generate_jacobian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the jacobian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.generate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_factorized_W","text":"generate_factorized_W(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the factorized W-matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#ModelingToolkit.generate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_hessian","text":"generate_hessian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the hessian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"systems/AbstractSystem/#Problem-Constructors-1","page":"The AbstractSystem Interface","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"At the end, the system types have DEProblem constructors, like ODEProblem, which allow for directly generating the problem types required for numerical methods. The first argument is always the AbstractSystem, and the proceeding arguments match the argument order of their original constructors. Whenever an array would normally be provided, such as u0 the initial condition of an ODEProblem, it is instead replaced with a variable map, i.e. an array of pairs var=>value which allows the user to designate the values without having to know the order that ModelingToolkit is internally using.","category":"page"},{"location":"IR/#ModelingToolkit-IR-1","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"ModelingToolkit IR, which falls under the Expression abstract type, mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the Variable type which defines a symbolic variable. These variables are combined using Operations, which are registered functions applied to the various variables. These Operations then perform automatic tracing, so normal mathematical functions applied to an Operation generate a new Operation. For example, op1 = x+y is one Operation and op2 = 2z is another, and so op1*op2 is another Operation. Then at the top, an Equation, normally written as op1 ~ op2, defines the symbolic equality between two operations.","category":"page"},{"location":"IR/#Types-1","page":"ModelingToolkit IR","title":"Types","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"Expression\r\nVariable\r\nModelingToolkit.Constant\r\nOperation\r\nEquation","category":"page"},{"location":"IR/#ModelingToolkit.Expression","page":"ModelingToolkit IR","title":"ModelingToolkit.Expression","text":"abstract type Expression <: Number\n\nBase type for a symbolic expression.\n\n\n\n\n\n","category":"type"},{"location":"IR/#ModelingToolkit.Variable","page":"ModelingToolkit IR","title":"ModelingToolkit.Variable","text":"struct Variable{T} <: Function\n\nA named variable which represents a numerical value. The variable is uniquely identified by its name, and all variables with the same name are treated as equal.\n\nFields\n\nname\nThe variable's unique name.\n\nFor example, the following code defines an independent variable t, a parameter α, a function parameter σ, a variable x which depends on t, a variable y with no dependents, a variable z which depends on t, α, and x(t) and a parameters β₁ and β₂.\n\nt = Variable(:t)()  # independent variables are treated as known\nα = Variable(:α)()  # parameters are known\nσ = Variable(:σ)    # left uncalled, since it is used as a function\nw = Variable(:w)   # unknown, left uncalled\nx = Variable(:x)(t)  # unknown, depends on `t`\ny = Variable(:y)()   # unknown, no dependents\nz = Variable(:z)(t, α, x)  # unknown, multiple arguments\nβ₁ = Variable(:β, 1)() # with index 1\nβ₂ = Variable(:β, 2)() # with index 2\n\nexpr = β₁ * x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)\n\n\n\n\n\n","category":"type"},{"location":"IR/#ModelingToolkit.Constant","page":"ModelingToolkit IR","title":"ModelingToolkit.Constant","text":"struct Constant <: Expression\n\nAn expression which wraps a constant numerical value.\n\n\n\n\n\n","category":"type"},{"location":"IR/#ModelingToolkit.Operation","page":"ModelingToolkit IR","title":"ModelingToolkit.Operation","text":"struct Operation <: Expression\n\nAn expression representing the application of a function to symbolic arguments.\n\nFields\n\nop\nThe function to be applied.\nargs\nThe arguments the function is applied to.\n\nExamples\n\nOperations can be built by application of most built-in mathematical functions to other Expression instances:\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> op1 = sin(x)\nsin(x())\n\njulia> typeof(op1.op)\ntypeof(sin)\n\njulia> op1.args\n1-element Array{Expression,1}:\n x()\n\njulia> op2 = x + y\nx() + y()\n\njulia> typeof(op2.op)\ntypeof(+)\n\njulia> op2.args\n2-element Array{Expression,1}:\n x()\n y()\n\n\n\n\n\n","category":"type"},{"location":"IR/#ModelingToolkit.Equation","page":"ModelingToolkit IR","title":"ModelingToolkit.Equation","text":"struct Equation\n\nAn equality relationship between two expressions.\n\nFields\n\nlhs\nThe expression on the left hand side of the equation.\nrhs\nThe expression on the right hand side of the equation.\n\n\n\n\n\n","category":"type"},{"location":"IR/#Function-Registration-1","page":"ModelingToolkit IR","title":"Function Registration","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"The ModelingToolkit graph only allowed for registered Julia functions for the operations. All other functions are automatically traced down to registred functions. By default, ModelingToolkit.jl pre-registers the common functions utilized in the AD package ruleset DiffRules.jl and pre-defines their derivatives. However, the user can utilize the @register macro to add their function to allowed functions of the computation graph.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"@register","category":"page"},{"location":"IR/#ModelingToolkit.@register","page":"ModelingToolkit IR","title":"ModelingToolkit.@register","text":"Registers a function call as a primative for the Operation graph of the ModelingToolkit IR. Example:\n\n@register f(x,y)\n\nregisters f as a possible two-argument function.\n\n\n\n\n\n","category":"macro"},{"location":"IR/#Derivatives-and-Differentials-1","page":"ModelingToolkit IR","title":"Derivatives and Differentials","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"A Differential(op) is a partial derivative with respect to the operation op which can then be applied to some other operations. For example D=Differential(t) is what would commonly be referred to as d/dt, which can then be applied to other operations using its function call, so D(x+y) is d(x+y)/dt.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"By default, the derivatives are left unexpanded to capture the symbolic representation of the differential equation. If the user would like to expand out all of the differentials, the expand_derivatives function eliminates all of the differentials down to basic one-variable expressions.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"Differential\r\nexpand_derivatives\r\nModelingToolkit.derivative\r\nModelingToolkit.gradient\r\nModelingToolkit.jacobian\r\nModelingToolkit.hessian","category":"page"},{"location":"IR/#ModelingToolkit.Differential","page":"ModelingToolkit IR","title":"ModelingToolkit.Differential","text":"struct Differential <: Function\n\nRepresents a differential operator.\n\nFields\n\nx\nThe variable or expression to differentiate with respect to.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> D = Differential(x)\n(D'~x())\n\njulia> D(y)  # Differentiate y wrt. x\n(D'~x())(y())\n\n\n\n\n\n","category":"type"},{"location":"IR/#ModelingToolkit.expand_derivatives","page":"ModelingToolkit IR","title":"ModelingToolkit.expand_derivatives","text":"expand_derivatives(O)\nexpand_derivatives(O, simplify)\n\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"IR/#ModelingToolkit.derivative","page":"ModelingToolkit IR","title":"ModelingToolkit.derivative","text":"derivative(O, idx)\n\n\nCalculate the derivative of the op O with respect to its argument with index idx.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> ModelingToolkit.derivative(sin(x), 1)\ncos(x())\n\nNote that the function does not recurse into the operation's arguments, i.e. the chain rule is not applied:\n\njulia> myop = sin(x) * y^2\nsin(x()) * y() ^ 2\n\njulia> typeof(myop.op)  # Op is multiplication function\ntypeof(*)\n\njulia> ModelingToolkit.derivative(myop, 1)  # wrt. sin(x)\ny() ^ 2\n\njulia> ModelingToolkit.derivative(myop, 2)  # wrt. y^2\nsin(x())\n\n\n\n\n\n","category":"function"},{"location":"IR/#ModelingToolkit.gradient","page":"ModelingToolkit IR","title":"ModelingToolkit.gradient","text":"gradient(O::Expression, vars::AbstractVector{<:Expression}; simplify = true)\n\nA helper function for computing the gradient of an expression with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"IR/#ModelingToolkit.jacobian","page":"ModelingToolkit IR","title":"ModelingToolkit.jacobian","text":"jacobian(O::Expression, vars::AbstractVector{<:Expression}; simplify = true)\n\nA helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"IR/#ModelingToolkit.hessian","page":"ModelingToolkit IR","title":"ModelingToolkit.hessian","text":"hessian(O::Expression, vars::AbstractVector{<:Expression}; simplify = true)\n\nA helper function for computing the Hessian of an expression with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"Note that generation of sparse matrices simply follows from the Julian semantics imbued on the IR, so sparse(jac) changes a dense Jacobian to a sparse Jacobian matrix.","category":"page"},{"location":"IR/#Adding-Derivatives-1","page":"ModelingToolkit IR","title":"Adding Derivatives","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"There is a large amount of derivatives pre-defined by DiffRules.jl. Note that Expression types are defined as <:Real, and thus any functions which allow the use of real numbers can automatically be traced by the derivative mechanism. Thus for example:","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"f(x,y,z) = x^2 + sin(x+y) - z","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"# `N` arguments are accepted by the relevant method of `my_function`\r\nModelingToolkit.derivative(::typeof(my_function), args::NTuple{N,Any}, ::Val{i})","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"where i means that it's the derivative of the ith argument. args is the array of arguments, so for example if your function is f(x,t) then args = [x,t]. You should return an Operation for the derivative of your function.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"For example, sin(t)'s derivative (by t) is given by the following:","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"ModelingToolkit.derivative(::typeof(sin), args::NTuple{1,Any}, ::Val{1}) = cos(args[1])","category":"page"},{"location":"IR/#IR-Manipulation-1","page":"ModelingToolkit IR","title":"IR Manipulation","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"ModelingToolkit.jl provides functionality for easily manipulating Expression types. Most of the functionality comes by the Expression type obeying the standard mathematical semantics. For example, if one has A a matrix of Expression, then A^2 calculates the Expressions for the squared matrix. In that sense, it is encouraged that one uses standard Julia for performing a lot of the manipulation on the IR, as for example calculating the sparse form of the matrix via sparse(A) is valid, legible, and easily understandable to all Julia programmers.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"Other additional manipulation functions are given below.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"simplify_constants\r\nrename\r\nget_variables\r\nsubstitute_expr!","category":"page"},{"location":"IR/#ModelingToolkit.rename","page":"ModelingToolkit IR","title":"ModelingToolkit.rename","text":"rename(x::Variable, name::Symbol) -> Variable{_A} where _A\n\n\nRenames the variable x to have name.\n\n\n\n\n\n","category":"function"},{"location":"IR/#Expression-Generation-and-build_function-1","page":"ModelingToolkit IR","title":"Expression Generation and build_function","text":"","category":"section"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"At any time, Julia expressions can be generated from ModelingToolkit IR by using convert(Expr,x). This performs some cleaning to return an expression without extraneous pieces that commonly matches expressions one would write in functions like those for differential equation solvers and optimization libraries.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"Additionally, the core compilation process of ModelingToolkit IR is build_function. build_function takes an operation or an AbstractArray of operations and generates a compile-able version of the model for numerical solvers.","category":"page"},{"location":"IR/#","page":"ModelingToolkit IR","title":"ModelingToolkit IR","text":"build_function","category":"page"},{"location":"IR/#ModelingToolkit.build_function","page":"ModelingToolkit IR","title":"ModelingToolkit.build_function","text":"build_function\n\nGenerates a numerically-usable function from a ModelingToolkit Expression. If the Expression is an Operation, the generated function is a function with a scalar output, otherwise if it's an AbstractArray{Operation} the output is two functions, one for out-of-place AbstractArray output and a second which is a mutating function. The outputted functions match the given argument order, i.e. f(u,p,args...) for the out-of-place and scalar functions and f!(du,u,p,args..) for the in-place version.\n\nbuild_function(ex, args...;\n               conv = simplified_expr, expression = Val{true},\n               checkbounds = false, constructor=nothing,\n               linenumbers = false, target = JuliaTarget())\n\nArguments:\n\nex: The Expression to compile\nvs: The variables of the expression\nps: The parameters of the expression\nargs: Extra arguments to the function\nconv: The conversion function of the Operation to Expr. By default this uses the simplified_expr function utilized in convert(Expr,x).\nexpression: Whether to generate code or whether to generate the compiled form. By default, expression = Val{true}, which means that the code for the function is returned. If Val{false}, then the returned value is a compiled Julia function which utilizes GeneralizedGenerated.jl in order to world-age free.\n\nKeyword Arguments:\n\ncheckbounds: For whether to enable bounds checking inside of the generated function. Defaults to false, meaning that @inbounds is applied.\nconstructor: Allows for an arbitrary constructor function to be passed in for handling expressions of \"weird\" types. Defaults to nothing.\nlinenumbers: Determines whether the generated function expression retains the line numbers. Defaults to true.\ntarget: The output target of the compilation process. Possible options are:\nJuliaTarget: Generates a Julia function\nCTarget: Generates a C function\nStanTarget: Generates a function for compiling with the Stan probabilistic programming language\nMATLABTarget: Generates an anonymous function for use in MATLAB and Octave environments\n\n\n\n\n\n","category":"function"},{"location":"systems/NonlinearSystem/#NonlinearSystem-1","page":"NonlinearSystem","title":"NonlinearSystem","text":"","category":"section"},{"location":"systems/NonlinearSystem/#System-Constructors-1","page":"NonlinearSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearSystem","category":"page"},{"location":"systems/NonlinearSystem/#ModelingToolkit.NonlinearSystem","page":"NonlinearSystem","title":"ModelingToolkit.NonlinearSystem","text":"struct NonlinearSystem <: ModelingToolkit.AbstractSystem\n\nA nonlinear system of equations.\n\nFields\n\neqs\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\nns = NonlinearSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/NonlinearSystem/#Composition-and-Accessor-Functions-1","page":"NonlinearSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"sys.eqs or equations(sys): The equations that define the nonlinear system.\nsys.states or states(sys): The set of states in the nonlinear system.\nsys.parameters or parameters(sys): The parameters of the nonlinear system.","category":"page"},{"location":"systems/NonlinearSystem/#Transformations-1","page":"NonlinearSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/NonlinearSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"NonlinearSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"calculate_jacobian\r\ngenerate_jacobian","category":"page"},{"location":"systems/NonlinearSystem/#Problem-Constructors-1","page":"NonlinearSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearProblem","category":"page"},{"location":"systems/NonlinearSystem/#DiffEqBase.NonlinearProblem","page":"NonlinearSystem","title":"DiffEqBase.NonlinearProblem","text":"function DiffEqBase.NonlinearProblem{iip}(sys::NonlinearSystem,u0map,tspan,\n                                          parammap=DiffEqBase.NullParameters();\n                                          jac = false, sparse=false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an NonlinearProblem from a NonlinearSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#SDESystem-1","page":"SDESystem","title":"SDESystem","text":"","category":"section"},{"location":"systems/SDESystem/#System-Constructors-1","page":"SDESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDESystem","category":"page"},{"location":"systems/SDESystem/#ModelingToolkit.SDESystem","page":"SDESystem","title":"ModelingToolkit.SDESystem","text":"struct SDESystem <: ModelingToolkit.AbstractODESystem\n\nA system of stochastic differential equations.\n\nFields\n\neqs\nThe expressions defining the drift term.\nnoiseeqs\nThe expressions defining the diffusion term.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nSystems: the internal systems\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\n@derivatives D'~t\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nnoiseeqs = [0.1*x,\n            0.1*y,\n            0.1*z]\n\nde = SDESystem(eqs,noiseeqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#Composition-and-Accessor-Functions-1","page":"SDESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"sys.eqs or equations(sys): The equations that define the SDE.\nsys.states or states(sys): The set of states in the SDE.\nsys.parameters or parameters(sys): The parameters of the SDE.\nsys.iv or independent_variable(sys): The independent variable of the SDE.","category":"page"},{"location":"systems/SDESystem/#Transformations-1","page":"SDESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/SDESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"SDESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W","category":"page"},{"location":"systems/SDESystem/#Problem-Constructors-1","page":"SDESystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDEFunction\r\nSDEProblem","category":"page"},{"location":"systems/SDESystem/#DiffEqBase.SDEFunction","page":"SDESystem","title":"DiffEqBase.SDEFunction","text":"function DiffEqBase.SDEFunction{iip}(sys::SDESystem, dvs = sys.states, ps = sys.ps;\n                                     version = nothing, tgrad=false, sparse = false,\n                                     jac = false, Wfact = false, kwargs...) where {iip}\n\nCreate an SDEFunction from the SDESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#DiffEqBase.SDEProblem","page":"SDESystem","title":"DiffEqBase.SDEProblem","text":"function DiffEqBase.SDEProblem{iip}(sys::SDESystem,u0map,tspan,p=parammap;\n                                    version = nothing, tgrad=false,\n                                    jac = false, Wfact = false,\n                                    checkbounds = false, sparse = false,\n                                    sparsenoise = sparse,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...)\n\nGenerates an SDEProblem from an SDESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#High-Level-API-1","page":"High Level API","title":"High Level API","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"The high level API allows modelers to interactively build models in a symbolic manner. It is designed as a semi-DSL for easily building large complex models and manipulating the models to generate optimal forms for utilizing in numerical methods.","category":"page"},{"location":"highlevel/#Examples-1","page":"High Level API","title":"Examples","text":"","category":"section"},{"location":"highlevel/#Example-1:-Symbolically-Building-an-ODEProblem-for-DifferentialEquations.jl-1","page":"High Level API","title":"Example 1: Symbolically Building an ODEProblem for DifferentialEquations.jl","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Let's build an ODE. First we define some variables. In a differential equation system, we need to differentiate between our (dependent) variables and parameters. Therefore we label them as follows:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"using ModelingToolkit\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\n@derivatives D'~t","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Then we build the system:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"eqs = [D(x) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Each operation builds an Operation type, and thus eqs is an array of Operation and Variables. This holds a tree of the full system that can be analyzed by other programs. We can turn this into a ODESystem via:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"sys = ODESystem(eqs)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"This ODESystem can then be used to generate an ODEProblem by supplying the constructor with a map from the states of the system to their initial condition values and from the parameters of the system to their values. For example:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"u0 = [x => 1.0\r\n      y => 0.0\r\n      z => 0.0]\r\n\r\np  = [σ => 10.0\r\n      ρ => 28.0\r\n      β => 8/3]\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(sys,u0,tspan,p;jac=true,sparse=true)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Note that the additional jac=true tells the system to symbolically generate an optimized Jacobian function to enhance the differential equation solvers, and sparse tells it to build the ODEProblem with all of the enhancements setup for sparse Jacobians.","category":"page"},{"location":"highlevel/#Example-2:-Building-a-Component-Based-ODEProblem-1","page":"High Level API","title":"Example 2: Building a Component-Based ODEProblem","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"In addition, we can then use ModelingToolkit to compose multiple ODE subsystems. Let's define two interacting Lorenz equations:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"lorenz1 = ODESystem(eqs,name=:lorenz1)\r\nlorenz2 = ODESystem(eqs,name=:lorenz2)\r\n\r\n@variables α\r\n@parameters γ\r\nconnections = [0 ~ lorenz1.x + lorenz2.y + sin(α*γ)]\r\nconnected = ODESystem(connections,[α],[γ],systems=[lorenz1,lorenz2])","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"which is now a differential-algebraic equation (DAE) of 7 variables which has two independent Lorenz systems and an algebraic equation that determines α such that an implicit constraint holds. We can then define the resulting ODEProblem and send it over to DifferentialEquations.jl.","category":"page"},{"location":"highlevel/#Example-3:-Building-Nonlinear-Systems-to-Solve-with-NLsolve.jl-1","page":"High Level API","title":"Example 3: Building Nonlinear Systems to Solve with NLsolve.jl","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"In this example we will go one step deeper and showcase the direct function generation capabilities in ModelingToolkit.jl to build nonlinear systems. Let's say we wanted to solve for the steady state of the previous ODE. This is the nonlinear system defined by where the derivatives are zero. We use (unknown) variables for our nonlinear system.","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"using ModelingToolkit\r\n\r\n@variables x y z\r\n@parameters σ ρ β\r\n\r\n# Define a nonlinear system\r\neqs = [0 ~ σ*(y-x),\r\n       0 ~ x*(ρ-z)-y,\r\n       0 ~ x*y - β*z]\r\nns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\r\nnlsys_func = generate_function(ns)[2] # second is the inplace version","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"which generates:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"(var\"##MTIIPVar#405\", u, p)->begin\r\n        @inbounds begin\r\n                @inbounds begin\r\n                        let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                            var\"##MTIIPVar#405\"[1] = (*)(σ, (-)(y, x))\r\n                            var\"##MTIIPVar#405\"[2] = (-)((*)(x, (-)(ρ, z)), y)\r\n                            var\"##MTIIPVar#405\"[3] = (-)((*)(x, y), (*)(β, z))\r\n                        end\r\n                    end\r\n            end\r\n        nothing\r\n    end","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"We can use this to build a nonlinear function for use with NLsolve.jl:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"f = eval(nlsys_func)\r\ndu = zeros(3); u = ones(3)\r\nparams = (10.0,26.0,2.33)\r\nf(du,u,params)\r\ndu\r\n\r\n#=\r\n3-element Array{Float64,1}:\r\n  0.0\r\n 24.0\r\n -1.33\r\n =#","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"We can similarly ask to generate the in-place Jacobian function:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"j_func = generate_jacobian(ns)[2] # second is in-place\r\nj! = eval(j_func)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"which gives:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":":((var\"##MTIIPVar#582\", u, p)->begin\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:70 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =# @inbounds begin\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:72 =#\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =# @inbounds begin\r\n                          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =#\r\n                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                              var\"##MTIIPVar#582\"[1] = (*)(σ, -1)\r\n                              var\"##MTIIPVar#582\"[2] = (-)(ρ, z)\r\n                              var\"##MTIIPVar#582\"[3] = y\r\n                              var\"##MTIIPVar#582\"[4] = σ\r\n                              var\"##MTIIPVar#582\"[5] = -1\r\n                              var\"##MTIIPVar#582\"[6] = x\r\n                              var\"##MTIIPVar#582\"[7] = 0\r\n                              var\"##MTIIPVar#582\"[8] = (*)(x, -1)\r\n                              var\"##MTIIPVar#582\"[9] = (*)(-1, β)\r\n                          end\r\n                      end\r\n              end\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:74 =#\r\n          nothing\r\n      end)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Now we can call nlsolve by enclosing our parameters into the functions:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"using NLsolve\r\nnlsolve((out, x) -> f(out, x, params), (out, x) -> j!(out, x, params), ones(3))","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"If one would like the generated function to be a Julia function instead of an expression, and allow this function to be used from within the same world-age, one simply needs to pass Val{false} to tell it to generate the function, i.e.:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"nlsys_func = generate_function(ns, [x,y,z], [σ,ρ,β], expression=Val{false})[2]","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"which uses GeneralizedGenerated.jl to build a same world-age function on the fly without eval.","category":"page"},{"location":"highlevel/#High-Level-API-Documentation-1","page":"High Level API","title":"High Level API Documentation","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"@parameters\r\n@variables\r\n@derivatives\r\nBase.:~(::Expression, ::Expression)","category":"page"},{"location":"highlevel/#ModelingToolkit.@parameters","page":"High Level API","title":"ModelingToolkit.@parameters","text":"Define one or more known variables.\n\n\n\n\n\n","category":"macro"},{"location":"highlevel/#ModelingToolkit.@variables","page":"High Level API","title":"ModelingToolkit.@variables","text":"Define one or more unknown variables.\n\n@parameters t α σ(..) β[1:2]\n@variables w(..) x(t) y() z(t, α, x)\n\nexpr = β₁* x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)\n\nNote that @parameters and @variables implicitly add () to values that are not given a call. The former specifies the values as known, while the latter specifies it as unknown. (..) signifies that the value should be left uncalled.\n\nSometimes it is convenient to define arrays of variables to model things like x₁,…,x₃. The @variables and @parameters macros support this with the following syntax:\n\n@variables x[1:3];\nx\n\n3-element Array{Operation,1}:\n x₁()\n x₂()\n x₃()\n\n# support for arbitrary ranges and tensors\n@variables y[2:3,1:5:6];\ny\n\n2×2 Array{Operation,2}:\n    y₂̒₁() y₂̒₆()\n    y₃̒₁() y₃̒₆()\n\n# also works for dependent variables\n@parameters t; @variables z[1:3](t);\nz\n\n3-element Array{Operation,1}:\n z₁(t())\n z₂(t())\n z₃(t())\n\n\n\n\n\n","category":"macro"},{"location":"highlevel/#ModelingToolkit.@derivatives","page":"High Level API","title":"ModelingToolkit.@derivatives","text":"Define one or more differentials.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y z;\n\njulia> @derivatives Dx'~x Dy'~y  # Create differentials wrt. x and y\n((D'~x()), (D'~y()))\n\njulia> Dx(z)  # Differentiate z wrt. x\n(D'~x())(z())\n\njulia> Dy(z)  # Differentiate z wrt. y\n(D'~y())(z())\n\n\n\n\n\n","category":"macro"},{"location":"highlevel/#Base.:~-Tuple{Expression,Expression}","page":"High Level API","title":"Base.:~","text":"~(lhs::Expression, rhs::Expression) -> Equation\n\n\nCreate an Equation out of two Expression instances, or an Expression and a Number.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> x ~ y\nEquation(x(), y())\n\njulia> x - y ~ 0\nEquation(x() - y(), ModelingToolkit.Constant(0))\n\n\n\n\n\n","category":"method"},{"location":"highlevel/#Additional-High-Level-Explanations-and-Tips-1","page":"High Level API","title":"Additional High Level Explanations and Tips","text":"","category":"section"},{"location":"highlevel/#The-Auto-Detecting-System-Constructors-1","page":"High Level API","title":"The Auto-Detecting System Constructors","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"For the high level interface, the system constructors such as ODESystem have high level constructors which just take in the required equations and automatically parse the expressions to figure out the states and parameters of the system. The following high level constructors exist:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"ODESystem(eqs)\r\nNonlinearSystem(eqs)","category":"page"},{"location":"highlevel/#Direct-Tracing-1","page":"High Level API","title":"Direct Tracing","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Because the ModelingToolkit Expression types obey Julia-semantics, one can directly transform existing Julia functions into ModelingToolkit symbolic representations of the function by simply inputting the symbolic values into the function and using what is returned. For example, let's take the following numerical PDE discretization:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"using ModelingToolkit, LinearAlgebra, SparseArrays\r\n\r\n# Define the constants for the PDE\r\nconst α₂ = 1.0\r\nconst α₃ = 1.0\r\nconst β₁ = 1.0\r\nconst β₂ = 1.0\r\nconst β₃ = 1.0\r\nconst r₁ = 1.0\r\nconst r₂ = 1.0\r\nconst _DD = 100.0\r\nconst γ₁ = 0.1\r\nconst γ₂ = 0.1\r\nconst γ₃ = 0.1\r\nconst N = 8\r\nconst X = reshape([i for i in 1:N for j in 1:N],N,N)\r\nconst Y = reshape([j for i in 1:N for j in 1:N],N,N)\r\nconst α₁ = 1.0.*(X.>=4*N/5)\r\n\r\nconst Mx = Tridiagonal([1.0 for i in 1:N-1],[-2.0 for i in 1:N],[1.0 for i in 1:N-1])\r\nconst My = copy(Mx)\r\nMx[2,1] = 2.0\r\nMx[end-1,end] = 2.0\r\nMy[1,2] = 2.0\r\nMy[end,end-1] = 2.0\r\n\r\n# Define the discretized PDE as an ODE function\r\nfunction f!(du,u,p,t)\r\n   A = @view  u[:,:,1]\r\n   B = @view  u[:,:,2]\r\n   C = @view  u[:,:,3]\r\n  dA = @view du[:,:,1]\r\n  dB = @view du[:,:,2]\r\n  dC = @view du[:,:,3]\r\n  mul!(MyA,My,A)\r\n  mul!(AMx,A,Mx)\r\n  @. DA = _DD*(MyA + AMx)\r\n  @. dA = DA + α₁ - β₁*A - r₁*A*B + r₂*C\r\n  @. dB = α₂ - β₂*B - r₁*A*B + r₂*C\r\n  @. dC = α₃ - β₃*C + r₁*A*B - r₂*C\r\nend","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"We can then define the corresponding arrays as ModelingToolkit variables:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"# Define the initial condition as normal arrays\r\n@variables du[1:N,1:N,1:3] u[1:N,1:N,1:3] MyA[1:N,1:N] AMx[1:N,1:N] DA[1:N,1:N]\r\nf!(du,u,nothing,0.0)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"The output, here the in-place modified du, is a symbolic representation of each output of the function. We can then utilize this in the ModelingToolkit functionality. For example, let's compute the sparse Jacobian function and compile a fast multithreaded version:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"jac = sparse(ModelingToolkit.jacobian(vec(du),vec(u),simplify=false))\r\nmultithreadedjac = eval(ModelingToolkit.build_function(vec(jac),u,multithread=true)[2])","category":"page"},{"location":"highlevel/#modelingtoolkitize-1","page":"High Level API","title":"modelingtoolkitize","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"For some DEProblem types, automatic tracing functionality is already included via the modelingtoolkitize function. Take for example the Robertson ODE defined as an ODEProblem for DifferentialEquations.jl:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"using DifferentialEquations\r\nfunction rober(du,u,p,t)\r\n  y₁,y₂,y₃ = u\r\n  k₁,k₂,k₃ = p\r\n  du[1] = -k₁*y₁+k₃*y₂*y₃\r\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\r\n  du[3] =  k₂*y₂^2\r\n  nothing\r\nend\r\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"If we want to get a symbolic representation, we can simply call modelingtoolkitize on the prob which will return an ODESystem:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"sys = modelingtoolkitize(prob)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"Using this, we can symbolically build the Jacobian and then rebuild the ODEProblem:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"jac = eval(ModelingToolkit.generate_jacobian(sys)[2])\r\n\r\nf = ODEFunction(rober, jac=jac)\r\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"modelingtoolkitize","category":"page"},{"location":"highlevel/#ModelingToolkit.modelingtoolkitize","page":"High Level API","title":"ModelingToolkit.modelingtoolkitize","text":"modelingtoolkitize(prob::ODEProblem) -> Union{Tuple{Any,Any,Any}, ODESystem}\n\n\nGenerate ODESystem, dependent variables, and parameters from an ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#Intermediate-Calculations-1","page":"High Level API","title":"Intermediate Calculations","text":"","category":"section"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"The system building functions can handle intermediate calculations by simply defining and using an Operation of Variables. For example:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"@variables x y z\r\n@parameters σ ρ β\r\na = y - x\r\neqs = [0 ~ σ*a,\r\n       0 ~ x*(ρ-z)-y,\r\n       0 ~ x*y - β*z]\r\nns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\r\nnlsys_func = generate_function(ns)[2] # second is the inplace version","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"expands to:","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":":((var\"##MTIIPVar#368\", var\"##MTKArg#365\", var\"##MTKArg#366\")->begin\r\n          @inbounds begin\r\n                  let (x, y, z, σ, ρ, β) = (var\"##MTKArg#365\"[1], var\"##MTKArg#365\"[2], var\"##MTKArg#365\"[3], var\"##MTKArg#366\"[1], var\"##MTKArg#366\"[2], var\"##MTKArg#366\"[3])\r\n                      var\"##MTIIPVar#368\"[1] = (*)(σ, (-)(y, x))\r\n                      var\"##MTIIPVar#368\"[2] = (-)((*)(x, (-)(ρ, z)), y)\r\n                      var\"##MTIIPVar#368\"[3] = (-)((*)(x, y), (*)(β, z))\r\n                  end\r\n              end\r\n          nothing\r\n      end)","category":"page"},{"location":"highlevel/#","page":"High Level API","title":"High Level API","text":"In addition, the Jacobian calculations take into account intermediate variables to appropriately handle them.","category":"page"},{"location":"systems/ODESystem/#ODESystem-1","page":"ODESystem","title":"ODESystem","text":"","category":"section"},{"location":"systems/ODESystem/#System-Constructors-1","page":"ODESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODESystem","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ODESystem","page":"ODESystem","title":"ModelingToolkit.ODESystem","text":"struct ODESystem <: ModelingToolkit.AbstractODESystem\n\nA system of ordinary differential equations.\n\nFields\n\neqs\nThe ODEs defining the system.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\n@derivatives D'~t\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nde = ODESystem(eqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#Composition-and-Accessor-Functions-1","page":"ODESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"sys.eqs or equations(sys): The equations that define the ODE.\nsys.states or states(sys): The set of states in the ODE.\nsys.parameters or parameters(sys): The parameters of the ODE.\nsys.iv or independent_variable(sys): The independent variable of the ODE.","category":"page"},{"location":"systems/ODESystem/#Transformations-1","page":"ODESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ode_order_lowering","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ode_order_lowering","page":"ODESystem","title":"ModelingToolkit.ode_order_lowering","text":"ode_order_lowering(sys::ODESystem) -> ODESystem\n\n\nTakes a Nth order ODESystem and returns a new ODESystem written in first order form by defining new variables which represent the N-1 derivatives.\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"ODESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W","category":"page"},{"location":"systems/ODESystem/#Problem-Constructors-1","page":"ODESystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODEFunction\r\nODEProblem","category":"page"},{"location":"systems/ODESystem/#DiffEqBase.ODEFunction","page":"ODESystem","title":"DiffEqBase.ODEFunction","text":"function DiffEqBase.ODEFunction{iip}(sys::AbstractODESystem, dvs = states(sys),\n                                     ps = parameters(sys);\n                                     version = nothing, tgrad=false,\n                                     jac = false, Wfact = false,\n                                     sparse = false,\n                                     kwargs...) where {iip}\n\nCreate an ODEFunction from the ODESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#DiffEqBase.ODEProblem","page":"ODESystem","title":"DiffEqBase.ODEProblem","text":"function DiffEqBase.ODEProblem{iip}(sys::AbstractODESystem,u0map,tspan,\n                                    parammap=DiffEqBase.NullParameters();\n                                    version = nothing, tgrad=false,\n                                    jac = false, Wfact = false,\n                                    checkbounds = false, sparse = false,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...) where iip\n\nGenerates an ODEProblem from an ODESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"#ModelingToolkit.jl-1","page":"Home","title":"ModelingToolkit.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl is a modeling language for high performance  symbolic-numeric computation in scientific computing  and scientific machine learning. It allows for users to give a high-level description of a model for symbolic preprocessing to analyze and enhance the model. ModelingToolkit can automatically generate fast functions for model components like Jacobians and Hessians, along with automatically sparsifying and parallelizing the computations. Automatic transformations, such as index reduction, can be applied to the model to make it easier for numerical solvers to handle.","category":"page"},{"location":"#Package-Overview-1","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit has 3 layers:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The model definition level. This is a high level of syntactic sugar for easily generating ModelingToolkit models. It can be used directly like a DSL for advanced users who want a lot of flexibility in a modeling language. Additionally, automatic tracing functionality allows for easily generating ModelingToolkit models directly from Julia code.\nThe AbstractSystem level. This is the level where content-dependent functionality is added, where models such an ordinary differential equation are represented. At the system level there are transformations which take one system to another, and targets which output code for numerical solvers.\nThe IR level, also referred to as the direct level. At this level, one directly acts on arrays of Equation, Operation and Variable types to generate functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Each level above is built on the level below, giving more context to allow for more automation. For example, the system level allows for automatically generating fast multithreaded sparse Jacobian functions of an ODESystem, which is just calling the sparsity functions and the multithreading capabilities of build_function at the IR level.","category":"page"},{"location":"systems/PDESystem/#PDESystem-1","page":"PDESystem","title":"PDESystem","text":"","category":"section"},{"location":"systems/PDESystem/#","page":"PDESystem","title":"PDESystem","text":"PDESystem is still a work in progress.","category":"page"}]
}
