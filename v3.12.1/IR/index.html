<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ModelingToolkit IR · ModelingToolkit.jl</title><link href="https://mtk.sciml.ai/stable/IR/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="ModelingToolkit.jl logo" src="../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">ModelingToolkit.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/ode_modeling/">Component-Based Modeling with Ordinary Differential Equations</a></li><li><a class="tocitem" href="../tutorials/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../tutorials/nonlinear/">Solving Nonlinear Systems with NLsolve</a></li><li><a class="tocitem" href="../tutorials/modelingtoolkitize/">Symbolic Extensions to ODEProblem via Modelingtoolkize</a></li><li><a class="tocitem" href="../tutorials/auto_parallel/">Automated Sparse Parallelism of ODEs via Tracing</a></li></ul></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../systems/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../systems/ReactionSystem/">ReactionSystem</a></li><li><a class="tocitem" href="../systems/PDESystem/">PDESystem</a></li><li><a class="tocitem" href="../systems/DependencyGraphs/">Dependency Graphs</a></li></ul></li><li><a class="tocitem" href="../highlevel/">High Level API</a></li><li class="is-active"><a class="tocitem" href="">ModelingToolkit IR</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">ModelingToolkit IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">ModelingToolkit IR</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/IR.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelingToolkit-IR-1"><a class="docs-heading-anchor" href="#ModelingToolkit-IR-1">ModelingToolkit IR</a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-IR-1" title="Permalink"></a></h1><p>ModelingToolkit IR, which falls under the <code>Expression</code> abstract type, mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the <code>Variable</code> type, which defines a symbolic variable. These variables are combined using <code>Operation</code>s, which are registered functions applied to the various variables. These <code>Operation</code>s then perform automatic tracing, so normal mathematical functions applied to an <code>Operation</code> generate a new <code>Operation</code>. For example, <code>op1 = x+y</code> is one <code>Operation</code> and <code>op2 = 2z</code> is another, and so <code>op1*op2</code> is another <code>Operation</code>. Then, at the top, an <code>Equation</code>, normally written as <code>op1 ~ op2</code>, defines the symbolic equality between two operations.</p><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Expression" id="ModelingToolkit.Expression"><code>ModelingToolkit.Expression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Expression &lt;: Number</code></pre><p>Base type for a symbolic expression.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/ModelingToolkit.jl#L28" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Variable" id="ModelingToolkit.Variable"><code>ModelingToolkit.Variable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Variable{T} &lt;: Function</code></pre><p>A named variable which represents a numerical value. The variable is uniquely identified by its <code>name</code>, and all variables with the same <code>name</code> are treated as equal.</p><p><strong>Fields</strong></p><ul><li><p><code>name</code></p><p>The variable's unique name.</p></li></ul><p>For example, the following code defines an independent variable <code>t</code>, a parameter <code>α</code>, a function parameter <code>σ</code>, a variable <code>x</code>, which depends on <code>t</code>, a variable <code>y</code> with no dependents, a variable <code>z</code>, which depends on <code>t</code>, <code>α</code>, and <code>x(t)</code> and parameters <code>β₁</code> and <code>β₂</code>.</p><pre><code class="language-julia">t = Variable(:t)()  # independent variables are treated as known
α = Variable(:α)()  # parameters are known
σ = Variable(:σ)    # left uncalled, since it is used as a function
w = Variable(:w)   # unknown, left uncalled
x = Variable(:x)(t)  # unknown, depends on `t`
y = Variable(:y)()   # unknown, no dependents
z = Variable(:z)(t, α, x)  # unknown, multiple arguments
β₁ = Variable(:β, 1)() # with index 1
β₂ = Variable(:β, 2)() # with index 2

expr = β₁ * x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)</code></pre></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/variables.jl#L17" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Constant" id="ModelingToolkit.Constant"><code>ModelingToolkit.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Constant &lt;: Expression</code></pre><p>An expression which wraps a constant numerical value.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/variables.jl#L75" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Operation" id="ModelingToolkit.Operation"><code>ModelingToolkit.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Operation &lt;: Expression</code></pre><p>An expression representing the application of a function to symbolic arguments.</p><p><strong>Fields</strong></p><ul><li><p><code>op</code></p><p>The function to be applied.</p></li><li><p><code>args</code></p><p>The arguments the function is applied to.</p></li></ul><p><strong>Examples</strong></p><p>Operations can be built by application of most built-in mathematical functions to other <a href="#ModelingToolkit.Expression"><code>Expression</code></a> instances:</p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; op1 = sin(x)
sin(x())

julia&gt; typeof(op1.op)
typeof(sin)

julia&gt; op1.args
1-element Array{Expression,1}:
 x()

julia&gt; op2 = x + y
x() + y()

julia&gt; typeof(op2.op)
typeof(+)

julia&gt; op2.args
2-element Array{Expression,1}:
 x()
 y()</code></pre></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/operations.jl#L1" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Equation" id="ModelingToolkit.Equation"><code>ModelingToolkit.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Equation</code></pre><p>An equality relationship between two expressions.</p><p><strong>Fields</strong></p><ul><li><p><code>lhs</code></p><p>The expression on the left-hand side of the equation.</p></li><li><p><code>rhs</code></p><p>The expression on the right-hand side of the equation.</p></li></ul></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/equations.jl#L1" target="_blank">source</a></section></article><h3 id="Function-Registration-1"><a class="docs-heading-anchor" href="#Function-Registration-1">Function Registration</a><a class="docs-heading-anchor-permalink" href="#Function-Registration-1" title="Permalink"></a></h3><p>The ModelingToolkit graph only allowed for registered Julia functions for the operations. All other functions are automatically traced down to registered functions. By default, ModelingToolkit.jl pre-registers the common functions utilized in the AD package ruleset <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a> and pre-defines their derivatives. However, the user can utilize the <code>@register</code> macro to add their function to allowed functions of the computation graph.</p><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.@register" id="ModelingToolkit.@register"><code>ModelingToolkit.@register</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Registers a function call as a primitive for the <code>Operation</code> graph of the ModelingToolkit IR. Example:</p><pre><code class="language-julia">@register f(x,y)</code></pre><p>registers <code>f</code> as a possible two-argument function.</p><p>You may also want to tell ModelingToolkit the derivative of the registered function. Here is an example to do it</p><pre><code class="language-julia">julia&gt; using ModelingToolkit

julia&gt; foo(x, y) = sin(x) * cos(y)
foo (generic function with 1 method)

julia&gt; @parameters t; @variables x(t) y(t) z(t); @derivatives D'~t;

julia&gt; @register foo(x, y)
foo (generic function with 4 methods)

julia&gt; foo(x, y)
foo(x(t), y(t))

julia&gt; ModelingToolkit.derivative(::typeof(foo), (x, y), ::Val{1}) = cos(x) * cos(y) # derivative w.r.t. the first argument

julia&gt; ModelingToolkit.derivative(::typeof(foo), (x, y), ::Val{2}) = -sin(x) * sin(y) # derivative w.r.t. the second argument

julia&gt; isequal(expand_derivatives(D(foo(x, y))), expand_derivatives(D(sin(x) * cos(y))))
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/function_registration.jl#L2" target="_blank">source</a></section></article><h3 id="Derivatives-and-Differentials-1"><a class="docs-heading-anchor" href="#Derivatives-and-Differentials-1">Derivatives and Differentials</a><a class="docs-heading-anchor-permalink" href="#Derivatives-and-Differentials-1" title="Permalink"></a></h3><p>A <code>Differential(op)</code> is a partial derivative with respect to the operation <code>op</code>, which can then be applied to some other operations. For example, <code>D=Differential(t)</code> is what would commonly be referred to as <code>d/dt</code>, which can then be applied to other operations using its function call, so <code>D(x+y)</code> is <code>d(x+y)/dt</code>.</p><p>By default, the derivatives are left unexpanded to capture the symbolic representation of the differential equation. If the user would like to expand out all of the differentials, the <code>expand_derivatives</code> function eliminates all of the differentials down to basic one-variable expressions.</p><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.Differential" id="ModelingToolkit.Differential"><code>ModelingToolkit.Differential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Differential &lt;: Function</code></pre><p>Represents a differential operator.</p><p><strong>Fields</strong></p><ul><li><p><code>x</code></p><p>The variable or expression to differentiate with respect to.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; D = Differential(x)
(D'~x())

julia&gt; D(y)  # Differentiate y wrt. x
(D'~x())(y())</code></pre></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/differentials.jl#L1" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.expand_derivatives" id="ModelingToolkit.expand_derivatives"><code>ModelingToolkit.expand_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_derivatives(O)
expand_derivatives(O, simplify)
</code></pre><p>TODO</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/differentials.jl#L34" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.derivative" id="ModelingToolkit.derivative"><code>ModelingToolkit.derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derivative(O, idx)
</code></pre><p>Calculate the derivative of the op <code>O</code> with respect to its argument with index <code>idx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; ModelingToolkit.derivative(sin(x), 1)
cos(x())</code></pre><p>Note that the function does not recurse into the operation's arguments, i.e., the chain rule is not applied:</p><pre><code class="language-julia-repl">julia&gt; myop = sin(x) * y^2
sin(x()) * y() ^ 2

julia&gt; typeof(myop.op)  # Op is multiplication function
typeof(*)

julia&gt; ModelingToolkit.derivative(myop, 1)  # wrt. sin(x)
y() ^ 2

julia&gt; ModelingToolkit.derivative(myop, 2)  # wrt. y^2
sin(x())</code></pre></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/differentials.jl#L76" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.gradient" id="ModelingToolkit.gradient"><code>ModelingToolkit.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gradient(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the gradient of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/direct.jl#L1-L8" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.jacobian" id="ModelingToolkit.jacobian"><code>ModelingToolkit.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(ops::AbstractVector{&lt;:Expression}, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/direct.jl#L13-L20" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.hessian" id="ModelingToolkit.hessian"><code>ModelingToolkit.hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hessian(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Hessian of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/direct.jl#L25-L32" target="_blank">source</a></section></article><p>Note that the generation of sparse matrices simply follows from the Julia semantics imbued on the IR, so <code>sparse(jac)</code> changes a dense Jacobian to a sparse Jacobian matrix.</p><h3 id="Adding-Derivatives-1"><a class="docs-heading-anchor" href="#Adding-Derivatives-1">Adding Derivatives</a><a class="docs-heading-anchor-permalink" href="#Adding-Derivatives-1" title="Permalink"></a></h3><p>There is a large amount of derivatives pre-defined by <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a>. Note that <code>Expression</code> types are defined as <code>&lt;:Real</code>, and thus any functions which allow the use of real numbers can automatically be traced by the derivative mechanism. Thus, for example:</p><pre><code class="language-julia">f(x,y,z) = x^2 + sin(x+y) - z</code></pre><p>automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.</p><p>However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:</p><pre><code class="language-julia"># `N` arguments are accepted by the relevant method of `my_function`
ModelingToolkit.derivative(::typeof(my_function), args::NTuple{N,Any}, ::Val{i})</code></pre><p>where <code>i</code> means that it's the derivative of the <code>i</code>th argument. <code>args</code> is the array of arguments, so, for example, if your function is <code>f(x,t)</code>, then <code>args = [x,t]</code>. You should return an <code>Operation</code> for the derivative of your function.</p><p>For example, <code>sin(t)</code>'s derivative (by <code>t</code>) is given by the following:</p><pre><code class="language-julia">ModelingToolkit.derivative(::typeof(sin), args::NTuple{1,Any}, ::Val{1}) = cos(args[1])</code></pre><h3 id="IR-Manipulation-1"><a class="docs-heading-anchor" href="#IR-Manipulation-1">IR Manipulation</a><a class="docs-heading-anchor-permalink" href="#IR-Manipulation-1" title="Permalink"></a></h3><p>ModelingToolkit.jl provides functionality for easily manipulating <code>Expression</code> types. Most of the functionality comes by the <code>Expression</code> type obeying the standard mathematical semantics. For example, if one has <code>A</code> a matrix of <code>Expression</code>, then <code>A^2</code> calculates the <code>Expression</code>s for the squared matrix. In that sense, it is encouraged that one uses standard Julia for performing a lot of the manipulation on the IR, as, for example, calculating the sparse form of the matrix via <code>sparse(A)</code> is valid, legible, and easily understandable to all Julia programmers.</p><p>Other additional manipulation functions are given below.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplify_constants</code>. Check Documenter's build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.rename" id="ModelingToolkit.rename"><code>ModelingToolkit.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename(x::Variable, name::Symbol) -&gt; Variable{_A} where _A
</code></pre><p>Renames the variable <code>x</code> to have <code>name</code>.</p></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/variables.jl#L228" target="_blank">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_variables</code>. Check Documenter's build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>substitute_expr!</code>. Check Documenter's build log for details.</p></div></div><h3 id="Expression-Generation-and-build_function-1"><a class="docs-heading-anchor" href="#Expression-Generation-and-build_function-1">Expression Generation and <code>build_function</code></a><a class="docs-heading-anchor-permalink" href="#Expression-Generation-and-build_function-1" title="Permalink"></a></h3><p>At any time, Julia expressions can be generated from ModelingToolkit IR by using <code>convert(Expr,x)</code>. This performs some cleaning to return an expression without extraneous pieces that commonly matches expressions one would write in functions like those for differential equation solvers and optimization libraries.</p><p>Additionally, the core compilation process of ModelingToolkit IR is <code>build_function</code>. <code>build_function</code> takes an operation or an <code>AbstractArray</code> of operations and generates a compilable version of the model for numerical solvers.</p><article class="docstring"><header><a class="docstring-binding" href="#ModelingToolkit.build_function" id="ModelingToolkit.build_function"><code>ModelingToolkit.build_function</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>build_function</code></p><p>Generates a numerically-usable function from a ModelingToolkit <code>Expression</code>. If the <code>Expression</code> is an <code>Operation</code>, the generated function is a function with a scalar output, otherwise if it's an <code>AbstractArray{Operation}</code>, the output is two functions, one for out-of-place AbstractArray output and a second which is a mutating function. The outputted functions match the given argument order, i.e., f(u,p,args...) for the out-of-place and scalar functions and <code>f!(du,u,p,args..)</code> for the in-place version.</p><pre><code class="language-julia">build_function(ex, args...;
               conv = simplified_expr, expression = Val{true},
               checkbounds = false,
               linenumbers = false, target = JuliaTarget())</code></pre><p>Arguments:</p><ul><li><code>ex</code>: The <code>Expression</code> to compile</li><li><code>vs</code>: The variables of the expression</li><li><code>ps</code>: The parameters of the expression</li><li><code>args</code>: Extra arguments to the function</li><li><code>conv</code>: The conversion function of the Operation to Expr. By default this uses the <code>simplified_expr</code> function utilized in <code>convert(Expr,x)</code>.</li><li><code>expression</code>: Whether to generate code or whether to generate the compiled form. By default, <code>expression = Val{true}</code>, which means that the code for the function is returned. If <code>Val{false}</code>, then the returned value is a compiled Julia function, which utilizes GeneralizedGenerated.jl in order to world-age free.</li></ul><p>Keyword Arguments:</p><ul><li><code>checkbounds</code>: For whether to enable bounds checking inside of the generated function. Defaults to false, meaning that <code>@inbounds</code> is applied.</li><li><code>linenumbers</code>: Determines whether the generated function expression retains the line numbers. Defaults to true.</li><li><code>target</code>: The output target of the compilation process. Possible options are:<ul><li><code>JuliaTarget</code>: Generates a Julia function</li><li><code>CTarget</code>: Generates a C function</li><li><code>StanTarget</code>: Generates a function for compiling with the Stan probabilistic programming language</li><li><code>MATLABTarget</code>: Generates an anonymous function for use in MATLAB and Octave environments</li></ul></li></ul></div><a class="docs-sourcelink" href="https://github.com/SciML/ModelingToolkit.jl/blob/b328c1bc90c30d2017b8d39b239385a1bba508ea/src/build_function.jl#L13-L58" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../highlevel/">« High Level API</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 July 2020 03:14">Monday 6 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>