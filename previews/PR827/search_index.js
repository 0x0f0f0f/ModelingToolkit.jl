var documenterSearchIndex = {"docs":
[{"location":"basics/AbstractSystem/#The-AbstractSystem-Interface-1","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"","category":"section"},{"location":"basics/AbstractSystem/#Overview-1","page":"The AbstractSystem Interface","title":"Overview","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The AbstractSystem interface is the core of the system level of ModelingToolkit.jl. It establishes a common set of functionality that is used between systems from ODEs and chemical reactions, allowing users to have a common framework for model manipulation and compilation.","category":"page"},{"location":"basics/AbstractSystem/#Constructors-and-Naming-1","page":"The AbstractSystem Interface","title":"Constructors and Naming","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The AbstractSystem interface has a consistent method for constructing systems. Generally it follows the order of:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Equations\nIndependent Variables\nDependent Variables (or States)\nParameters","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"All other pieces are handled via keyword arguments. AbstractSystems share the same keyword arguments, which are:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"system: This is used for specifying subsystems for hierarchical modeling with reusable components. For more information, see the components page\nDefaults: Keyword arguments like default_u0 are used for specifying default values which are used. If a value is not given at the SciMLProblem construction time, its numerical value will be the default.","category":"page"},{"location":"basics/AbstractSystem/#Composition-and-Accessor-Functions-1","page":"The AbstractSystem Interface","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Each AbstractSystem has lists of variables in context, such as distinguishing parameters vs states. In addition, an AbstractSystem also can hold other AbstractSystem types. Direct accessing of the values, such as sys.states, gives the immediate list, while the accessor functions states(sys) gives the total set, which includes that of all systems held inside.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The values which are common to all AbstractSystems are:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"equations(sys): All equations that define the system and its subsystems.\nstates(sys): All the states in the system and its subsystems.\nparameters(sys): All parameters of the system and its subsystems.\nnameof(sys): The name of the current-level system.\nget_eqs(sys): Equations that define the current-level system.\nget_states(sys): States that are in the current-level system.\nget_ps(sys): Parameters that are in the current-level system.\nget_systems(sys): Subsystems of the current-level system.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Optionally, a system could have:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"observed(sys): All observed equations of the system and its subsystems.\nget_observed(sys): Observed equations of the current-level system.\nget_default_u0(sys): A Dict that maps states into their default initial condition.\nget_default_p(sys): A Dict that maps parameters into their default value.\nindependent_variable(sys): The independent variable of a system.\nget_noiseeqs(sys): Noise equations of the current-level system.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Note that there's get_iv(sys), but it is not advised to use, since it errors when the system has no field iv. independent_variable(sys) returns nothing for NonlinearSystems.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"A system could also have caches:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"get_jac(sys): The Jacobian of a system.\nget_tgrad(sys): The gradient with respect to time of a system.","category":"page"},{"location":"basics/AbstractSystem/#Transformations-1","page":"The AbstractSystem Interface","title":"Transformations","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Transformations are functions which send a valid AbstractSystem definition to another AbstractSystem. These are passes, like optimizations (e.g., Block-Lower Triangle transformations), or changes to the representation, which allow for alternative numerical methods to be utilized on the model (e.g., DAE index reduction).","category":"page"},{"location":"basics/AbstractSystem/#Function-Calculation-and-Generation-1","page":"The AbstractSystem Interface","title":"Function Calculation and Generation","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The calculation and generation functions allow for calculating additional quantities to enhance the numerical methods applied to the resulting system. The calculations, like calculate_jacobian, generate ModelingToolkit IR for the Jacobian of the system, while the generations, like generate_jacobian, generate compiled output for the numerical solvers by applying build_function to the generated code. Additionally, many systems have function-type outputs, which cobble together the generation functionality for a system, for example, ODEFunction can be used to generate a DifferentialEquations-based ODEFunction with compiled version of the ODE itself, the Jacobian, the mass matrix, etc.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Below are the possible calculation and generation functions:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"calculate_tgrad\ncalculate_gradient\ncalculate_jacobian\ncalculate_factorized_W\ncalculate_hessian\ngenerate_tgrad\ngenerate_gradient\ngenerate_jacobian\ngenerate_factorized_W\ngenerate_hessian","category":"page"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_tgrad","text":"calculate_tgrad(sys::AbstractSystem)\n\nCalculate the time gradient of a system.\n\nReturns a vector of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_gradient","text":"calculate_gradient(sys::AbstractSystem)\n\nCalculate the gradient of a scalar system.\n\nReturns a vector of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_jacobian","text":"calculate_jacobian(sys::AbstractSystem)\n\nCalculate the jacobian matrix of a system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_factorized_W","text":"calculate_factorized_W(sys::AbstractSystem)\n\nCalculate the factorized W-matrix of a system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_hessian","text":"calculate_hessian(sys::AbstractSystem)\n\nCalculate the hessian matrix of a scalar system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_tgrad","text":"generate_tgrad(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the time gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_gradient","text":"generate_gradient(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_jacobian","text":"generate_jacobian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the jacobian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_factorized_W","text":"generate_factorized_W(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the factorized W-matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_hessian","text":"generate_hessian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the hessian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Additionally, jacobian_sparsity(sys) and hessian_sparsity(sys) exist on the appropriate systems for fast generation of the sparsity patterns via an abstract interpretation without requiring differentiation.","category":"page"},{"location":"basics/AbstractSystem/#Problem-Constructors-1","page":"The AbstractSystem Interface","title":"Problem Constructors","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"At the end, the system types have DEProblem constructors, like ODEProblem, which allow for directly generating the problem types required for numerical methods. The first argument is always the AbstractSystem, and the proceeding arguments match the argument order of their original constructors. Whenever an array would normally be provided, such as u0 the initial condition of an ODEProblem, it is instead replaced with a variable map, i.e., an array of pairs var=>value, which allows the user to designate the values without having to know the order that ModelingToolkit is internally using.","category":"page"},{"location":"systems/ReactionSystem/#ReactionSystem-1","page":"ReactionSystem","title":"ReactionSystem","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"A ReactionSystem represents a system of chemical reactions. Conversions are provided to generate corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models. As a simple example, the code below creates a SIR model, and solves the corresponding ODE, SDE, and jump process models.","category":"page"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"using ModelingToolkit, OrdinaryDiffEq, StochasticDiffEq, DiffEqJump\r\n@parameters β γ t\r\n@variables S(t) I(t) R(t)\r\n\r\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\r\n       Reaction(γ, [I], [R])]\r\nrs  = ReactionSystem(rxs, t, [S,I,R], [β,γ])\r\n\r\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\r\nparammap = [β => 1/10000, γ => 0.01]\r\ntspan    = (0.0, 250.0)\r\n\r\n# solve as ODEs\r\nodesys = convert(ODESystem, rs)\r\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\r\nsol = solve(oprob, Tsit5())\r\n\r\n# solve as SDEs\r\nsdesys = convert(SDESystem, rs)\r\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\r\nsol = solve(sprob, EM(), dt=.01)\r\n\r\n# solve as jump process\r\njumpsys = convert(JumpSystem, rs)\r\nu₀map    = [S => 999, I => 1, R => 0]\r\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\r\njprob = JumpProblem(jumpsys, dprob, Direct())\r\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"systems/ReactionSystem/#System-Constructors-1","page":"ReactionSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Reaction\r\nReactionSystem","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.Reaction","page":"ReactionSystem","title":"ModelingToolkit.Reaction","text":"struct Reaction{S, T<:Number}\n\nOne chemical reaction.\n\nFields\n\nrate\nThe rate function (excluding mass action terms).\nsubstrates\nReaction substrates.\nproducts\nReaction products.\nsubstoich\nThe stoichiometric coefficients of the reactants.\nprodstoich\nThe stoichiometric coefficients of the products.\nnetstoich\nThe net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate\nfalse (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nExamples\n\nusing ModelingToolkit\n@parameters t k[1:20]\n@variables A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#ModelingToolkit.ReactionSystem","page":"ReactionSystem","title":"ModelingToolkit.ReactionSystem","text":"struct ReactionSystem <: ModelingToolkit.AbstractSystem\n\nA system of chemical reactions.\n\nFields\n\neqs\nThe reactions defining the system.\niv\nIndependent variable (usually time).\nstates\nDependent (state) variables representing amount of each species.\nps\nParameter variables.\nobserved\nname\nThe name of the system\nsystems\nsystems: The internal systems\n\nExample\n\nContinuing from the example in the Reaction definition:\n\nrs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#Composition-and-Accessor-Functions-1","page":"ReactionSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"get_eqs(sys) or equations(sys): The reactions that define the system.\nget_states(sys) or states(sys): The set of chemical species in the system.\nget_ps(sys) or parameters(sys): The parameters of the system.\nindependent_variable(sys): The independent variable of the reaction system, usually time.","category":"page"},{"location":"systems/ReactionSystem/#Query-Functions-1","page":"ReactionSystem","title":"Query Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"oderatelaw\r\njumpratelaw\r\nismassaction","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.oderatelaw","page":"ReactionSystem","title":"ModelingToolkit.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the rate   law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling factor is   ignored.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#ModelingToolkit.jumpratelaw","page":"ReactionSystem","title":"ModelingToolkit.jumpratelaw","text":"jumpratelaw(rx; rxvars=get_variables(rx.rate), combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nrxvars should give the Variables, i.e. species and parameters, the rate depends on.\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#ModelingToolkit.ismassaction","page":"ReactionSystem","title":"ModelingToolkit.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = any(var -> isequal(get_iv(rs),var), rxvars),\n                              stateset = Set(states(rs)))\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on the independent variable.\nOptional: stateset, set of states which if the rxvars are within mean rx is non-mass action.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#Transformations-1","page":"ReactionSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Base.convert\r\nstructural_simplify","category":"page"},{"location":"systems/ReactionSystem/#Base.convert","page":"ReactionSystem","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ODESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an NonlinearSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\nnoise_scaling=nothing::Union{Vector{Operation},Operation,Nothing} allows for linear\n\nscaling of the noise in the chemical Langevin equations. If nothing is given, the default value as in Gillespie 2000 is used. Alternatively, an Operation can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the ReactionSystem. Finally, a Vector{Operation} can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/ode_modeling/#Component-Based-Modeling-with-Ordinary-Differential-Equations-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"","category":"section"},{"location":"tutorials/ode_modeling/#Copy-Paste-Example-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Copy-Paste Example","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Here is the complete example, with explanation to follow:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"using ModelingToolkit, OrdinaryDiffEq\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)\r\n\r\neqs = [D(x) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]\r\n\r\n@named lorenz1 = ODESystem(eqs)\r\n@named lorenz2 = ODESystem(eqs)\r\n\r\n@variables a\r\n@parameters γ\r\nconnections = [0 ~ lorenz1.x + lorenz2.y + a*γ]\r\n@named connected = ODESystem(connections,t,[a],[γ],systems=[lorenz1,lorenz2])\r\n\r\nu0 = [lorenz1.x => 1.0,\r\n      lorenz1.y => 0.0,\r\n      lorenz1.z => 0.0,\r\n      lorenz2.x => 0.0,\r\n      lorenz2.y => 1.0,\r\n      lorenz2.z => 0.0,\r\n      a => 2.0]\r\n\r\np  = [lorenz1.σ => 10.0,\r\n      lorenz1.ρ => 28.0,\r\n      lorenz1.β => 8/3,\r\n      lorenz2.σ => 10.0,\r\n      lorenz2.ρ => 28.0,\r\n      lorenz2.β => 8/3,\r\n      γ => 2.0]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(connected,u0,tspan,p)\r\nsol = solve(prob,Rodas4())\r\n\r\nusing Plots; plot(sol,vars=(a,lorenz1.x,lorenz2.z))","category":"page"},{"location":"tutorials/ode_modeling/#Generating-ODESystems-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Generating ODESystems","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"First let's build an ODE model. To do this we start by defining some variables. In a differential equation system, we need to differentiate between our (dependent) variables and parameters. Therefore, we label them as follows:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"using ModelingToolkit\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Then we build the system:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"eqs = [D(x) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Each operation builds an Term type, and thus eqs is an array of Term and Syms (possibly wrapped in Num). This holds a tree of the full system that can be analyzed by other programs. We can turn this into a ODESystem via:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"sys = ODESystem(eqs)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"This ODESystem can then be used to generate an ODEProblem by supplying the constructor with a map from the states of the system to their initial condition values and from the parameters of the system to their values. For example:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"u0 = [x => 1.0\r\n      y => 0.0\r\n      z => 0.0]\r\n\r\np  = [σ => 10.0\r\n      ρ => 28.0\r\n      β => 8/3]\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(sys,u0,tspan,p;jac=true,sparse=true)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Note that the additional jac=true tells the system to symbolically generate an optimized Jacobian function to enhance the differential equation solvers, and sparse tells it to build the ODEProblem with all of the enhancements setup for sparse Jacobians.","category":"page"},{"location":"tutorials/ode_modeling/#Building-Component-Based-Models-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Building Component-Based Models","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Now let's use ModelingToolkit to start building component-based models. Component-based models are compositions between submodels. This allows one to keep independently generated libraries of components intact and use them as the building blocks to construct more complicated models.","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Let's define two interacting Lorenz equations. To do this, we will build two ODESystems from the equations we used in the first part:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"@named lorenz1 = ODESystem(eqs)\r\n@named lorenz2 = ODESystem(eqs)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Now let's define an interconnection between these ODE systems. Here we will define a new variable α which is defined by the interplay between these two models:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"@variables a(t)\r\n@parameters γ\r\nconnections = [0 ~ lorenz1.x + lorenz2.y + a*γ]\r\n@named connected = ODESystem(connections,t,[a],[γ],systems=[lorenz1,lorenz2])","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"This ODESystem thus connects the two Lorenz systems and defines the dynamics of α according to the continuous algebraic equation, thus this is now a differential-algebraic equation (DAE) of 7 variables. We can then define the resulting ODEProblem and send it over to DifferentialEquations.jl:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"u0 = [lorenz1.x => 1.0,\r\n      lorenz1.y => 0.0,\r\n      lorenz1.z => 0.0,\r\n      lorenz2.x => 0.0,\r\n      lorenz2.y => 1.0,\r\n      lorenz2.z => 0.0,\r\n      a => 2.0]\r\n\r\np  = [lorenz1.σ => 10.0,\r\n      lorenz1.ρ => 28.0,\r\n      lorenz1.β => 8/3,\r\n      lorenz2.σ => 10.0,\r\n      lorenz2.ρ => 28.0,\r\n      lorenz2.β => 8/3,\r\n      γ => 2.0]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(connected,u0,tspan,p)\r\nsol = solve(prob,Rodas4())\r\n\r\nusing Plots; plot(sol,vars=(a,lorenz1.x,lorenz2.z))","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"systems/NonlinearSystem/#NonlinearSystem-1","page":"NonlinearSystem","title":"NonlinearSystem","text":"","category":"section"},{"location":"systems/NonlinearSystem/#System-Constructors-1","page":"NonlinearSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearSystem","category":"page"},{"location":"systems/NonlinearSystem/#ModelingToolkit.NonlinearSystem","page":"NonlinearSystem","title":"ModelingToolkit.NonlinearSystem","text":"struct NonlinearSystem <: ModelingToolkit.AbstractSystem\n\nA nonlinear system of equations.\n\nFields\n\neqs\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nobserved\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nstructure\nstructure: structural information of the system\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\nns = NonlinearSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/NonlinearSystem/#Composition-and-Accessor-Functions-1","page":"NonlinearSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"get_eqs(sys) or equations(sys): The equations that define the nonlinear system.\nget_states(sys) or states(sys): The set of states in the nonlinear system.\nget_ps(sys) or parameters(sys): The parameters of the nonlinear system.","category":"page"},{"location":"systems/NonlinearSystem/#Transformations-1","page":"NonlinearSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"structural_simplify\r\nalias_elimination\r\ntearing","category":"page"},{"location":"systems/NonlinearSystem/#ModelingToolkit.StructuralTransformations.tearing","page":"NonlinearSystem","title":"ModelingToolkit.StructuralTransformations.tearing","text":"tearing(sys; simplify=false)\n\nTear the nonlinear equations in system. When simplify=true, we simplify the new residual residual equations after tearing.\n\n\n\n\n\n","category":"function"},{"location":"systems/NonlinearSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"NonlinearSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"calculate_jacobian\r\ngenerate_jacobian\r\njacobian_sparsity","category":"page"},{"location":"systems/NonlinearSystem/#Problem-Constructors-1","page":"NonlinearSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearProblem","category":"page"},{"location":"systems/NonlinearSystem/#SciMLBase.NonlinearProblem","page":"NonlinearSystem","title":"SciMLBase.NonlinearProblem","text":"function DiffEqBase.NonlinearProblem{iip}(sys::NonlinearSystem,u0map,\n                                          parammap=DiffEqBase.NullParameters();\n                                          jac = false, sparse=false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an NonlinearProblem from a NonlinearSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/NonlinearSystem/#Torn-Problem-Constructors-1","page":"NonlinearSystem","title":"Torn Problem Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"BlockNonlinearProblem","category":"page"},{"location":"comparison/#Comparison-of-ModelingToolkit-vs-Equation-Based-Modeling-Languages-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"","category":"section"},{"location":"comparison/#Comparison-Against-Modelica-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison Against Modelica","text":"","category":"section"},{"location":"comparison/#","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"Both Modelica and ModelingToolkit.jl are acausal modeling languages.\nModelica is a language with many different implementations, such as Dymola and OpenModelica, which have differing levels of performance and can give different results on the same model. Many of the commonly used Modelica compilers are not open source. ModelingToolkit.jl is a language with a single canonical open source implementation.\nAll current Modelica compiler implementations are fixed and not extendable by the users from the Modelica language itself. For example, the Dymola compiler shares its symbolic processing pipeline which is roughly equivalent to the dae_index_lowering and structural_simplify of ModelingToolkit.jl. ModelingToolkit.jl is an open and hackable transformation system which allows users to add new non-standard transformations and control the order of application.\nModelica is a declarative programming language. ModelingToolkit.jl is a declarative symbolic modeling language used from within the Julia programming language. Its programming language semantics, such as loop constructs and conditionals, can be used to more easily generate models.\nModelica is an object-oriented single dispatch language. ModelingToolkit.jl, built on Julia, uses multiple dispatch extensively to simplify code.\nMany Modelica compilers supply a GUI. ModelingToolkit.jl does not.\nModelica can be used to simulate ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including nonlinear systems, SDEs, PDEs, and more.","category":"page"},{"location":"comparison/#Comparison-Against-Simulink-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison Against Simulink","text":"","category":"section"},{"location":"comparison/#","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"Simulink is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one. In this sense, ModelingToolkit.jl is more similar to the Simscape sub-environment.\nSimulink is used from MATLAB while ModelingToolkit.jl is used from Julia. Thus any user defined functions have the performance of their host language. For information on the performance differences between Julia and MATLAB, consult open benchmarks which demonstrate Julia as an order of magnitude or more faster in many cases due to its JIT compilation.\nSimulink uses the MATLAB differential equation solvers while ModelingToolkit.jl uses DifferentialEquations.jl. For a systematic comparison between the solvers, consult open benchmarks which demonstrate two orders of magnitude performance advantage for the native Julia solvers across many benchmark problems.\nSimulink comes with a Graphical User Interface (GUI), ModelingToolkit.jl does not.\nSimulink is a proprietary software, meaning users cannot actively modify or extend the software. ModelingToolkit.jl is built in Julia and used in Julia, where users can actively extend and modify the software interactively in the REPL and contribute to its open source repositories.\nSimulink covers ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"page"},{"location":"comparison/#Comparison-Against-CASADI-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison Against CASADI","text":"","category":"section"},{"location":"comparison/#","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"CASADI is written in C++ but used from Python/MATLAB, meaning that it cannot be directly extended by users unless they are using the C++ interface and run a local build of CASADI. ModelingToolkit.jl is both written and used from Julia, meaning that users can easily extend the library on the fly, even interactively in the REPL.\nCASADI includes limited support for Computer Algebra System (CAS) functionality, while ModelingToolkit.jl is built on the full Symbolics.jl CAS.\nCASADI supports DAE and ODE problems via SUNDIALS IDAS and CVODES. ModelingToolkit.jl supports DAE and ODE problems via DifferentialEquations.jl, of which Sundials.jl is <1% of the total available solvers and is outperformed by the native Julia solvers on the vast majority of the benchmark equations. In addition, the DifferentialEquations.jl interface is confederated, meaning that any user can dynamically extend the system to add new solvers to the interface by defining new dispatches of solve.\nCASADI's DAEBuilder does not implement efficiency transformations like tearing which are standard in the ModelingToolkit.jl transformation pipeline.\nCASADI supports special functionality for quadratic programming problems while ModelingToolkit only provides nonlinear programming via OptimizationSystem.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of CASADI must explicitly create CASADI expressions.","category":"page"},{"location":"comparison/#Comparison-Against-Modia.jl-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison Against Modia.jl","text":"","category":"section"},{"location":"comparison/#","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"Modia.jl is a Modelica-like system built in pure Julia. As such, its syntax is a domain-specific language (DSL) specified by macros to mirror the Modelica syntax.\nModia's compilation pipeline is similar to the Dymola symbolic processing pipeline with some improvements. ModelingToolkit.jl has an open transformation pipeline that allows for users to extend and reorder transformation passes, where structural_simplify is an adaptation of the Modia.jl-improved alias elimination and tearing algorithms.\nModia supports DAE problems via SUNDIALS IDAS. ModelingToolkit.jl supports DAE and ODE problems via DifferentialEquations.jl, of which Sundials.jl is <1% of the total available solvers and is outperformed by the native Julia solvers on the vast majority of the benchmark equations. In addition, the DifferentialEquations.jl interface is confederated, meaning that any user can dynamically extend the system to add new solvers to the interface by defining new dispatches of solve.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of Modia must explicitly create Modia expressions within its macro.\nModia covers DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"page"},{"location":"comparison/#Comparison-Against-Causal.jl-1","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison Against Causal.jl","text":"","category":"section"},{"location":"comparison/#","page":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based Modeling Languages","text":"Causal.jl is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one.\nBoth ModelingToolkit.jl and Causal.jl use DifferentialEquations.jl as the backend solver library.\nCausal.jl lets one add arbitrary equation systems to a given node, and allow the output to effect the next node. This means an SDE may drive an ODE. These two portions are solved with different solver methods in tandem. In ModelingToolkit.jl, such connections promote the whole system to an SDE. This results in better accuracy and stability, though in some cases it can be less performant.\nCausal.jl, similar to Simulink, breaks algebraic loops via inexact heuristics. ModelingToolkit.jl treats algebraic loops exactly through algebraic equations in the generated model.","category":"page"},{"location":"systems/ControlSystem/#ControlSystem-1","page":"ControlSystem","title":"ControlSystem","text":"","category":"section"},{"location":"systems/ControlSystem/#System-Constructors-1","page":"ControlSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"ControlSystem","category":"page"},{"location":"systems/ControlSystem/#ModelingToolkit.ControlSystem","page":"ControlSystem","title":"ModelingToolkit.ControlSystem","text":"struct ControlSystem <: ModelingToolkit.AbstractControlSystem\n\nA system describing an optimal control problem. This contains a loss function and ordinary differential equations with control variables that describe the dynamics.\n\nFields\n\nloss\nThe Loss function\neqs\nThe ODEs defining the system.\niv\nIndependent variable.\nstates\nDependent (state) variables.\ncontrols\nControl variables.\nps\nParameter variables.\nobserved\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@variables t x(t) v(t) u(t)\nD = Differential(t)\n\nloss = (4-x)^2 + 2v^2 + u^2\neqs = [\n    D(x) ~ v\n    D(v) ~ u^3\n]\n\nsys = ControlSystem(loss,eqs,t,[x,v],[u],[])\n\n\n\n\n\n","category":"type"},{"location":"systems/ControlSystem/#Composition-and-Accessor-Functions-1","page":"ControlSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"get_eqs(sys) or equations(sys): The equations that define the system.\nget_states(sys) or states(sys): The set of states in the system.\nget_ps(sys) or parameters(sys): The parameters of the system.\nget_controls(sys) or controls(sys): The control variables of the system","category":"page"},{"location":"systems/ControlSystem/#Transformations-1","page":"ControlSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"ModelingToolkit.runge_kutta_discretize\nstructural_simplify","category":"page"},{"location":"systems/ControlSystem/#ModelingToolkit.runge_kutta_discretize","page":"ControlSystem","title":"ModelingToolkit.runge_kutta_discretize","text":"runge_kutta_discretize(sys::ControlSystem,dt,tspan;\n                       tab = ModelingToolkit.constructRadauIIA5())\n\nTransforms a nonlinear optimal control problem into a constrained OptimizationProblem according to a Runge-Kutta tableau that describes a collocation method. Requires a fixed dt over a given timespan. Defaults to using the 5th order RadauIIA tableau, and altnerative tableaus can be specified using the SciML tableau style.\n\n\n\n\n\n","category":"function"},{"location":"systems/ControlSystem/#ModelingToolkit.structural_simplify","page":"ControlSystem","title":"ModelingToolkit.structural_simplify","text":"structural_simplify(sys)\n\n\nStructurally simplify algebraic equations in a system.\n\n\n\n\n\n","category":"function"},{"location":"basics/Composition/#[Composing-Models-and-Building-Reusable-Components](@ref-components)-1","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The symbolic models of ModelingToolkit can be composed together to easily build large models. The composition is lazy and only instantiated at the time of conversion to numerical models, allowing a more performant way in terms of computation time and memory.","category":"page"},{"location":"basics/Composition/#Simple-Model-Composition-Example-1","page":"Composing Models and Building Reusable Components","title":"Simple Model Composition Example","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The following is an example of building a model in a library with an optional forcing function, and allowing the user to specify the forcing later. Here, the library author defines a component named decay. The user then builds two decay components and connects them, saying the forcing term of decay1 is a constant while the forcing term of decay2 is the value of the state variable x.","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"using ModelingToolkit\n\nfunction decay(;name)\n  @parameters t a\n  @variables x(t) f(t)\n  D = Differential(t)\n  ODESystem([\n      D(x) ~ -a*x + f\n    ];\n    name=name)\nend\n\n@named decay1 = decay()\n@named decay2 = decay()\n\n@parameters t\nD = Differential(t)\n@named connected = ODESystem([\n                        decay2.f ~ decay1.x\n                        D(decay1.f) ~ 0\n                      ], t, systems=[decay1, decay2])\n\nequations(connected)\n\n#4-element Vector{Equation}:\n# Differential(t)(decay1₊f(t)) ~ 0\n# decay2₊f(t) ~ decay1₊x(t)\n# Differential(t)(decay1₊x(t)) ~ decay1₊f(t) - (decay1₊a*(decay1₊x(t)))\n# Differential(t)(decay2₊x(t)) ~ decay2₊f(t) - (decay2₊a*(decay2₊x(t)))\n\nsimplified_sys = structural_simplify(connected)\n\nequations(simplified_sys)\n\n#3-element Vector{Equation}:\n# Differential(t)(decay1₊f(t)) ~ 0\n# Differential(t)(decay1₊x(t)) ~ decay1₊f(t) - (decay1₊a*(decay1₊x(t)))\n# Differential(t)(decay2₊x(t)) ~ decay1₊x(t) - (decay2₊a*(decay2₊x(t)))","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Now we can solve the system:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"x0 = [\n  decay1.x => 1.0\n  decay1.f => 0.0\n  decay2.x => 1.0\n]\np = [\n  decay1.a => 0.1\n  decay2.a => 0.2\n]\n\nusing DifferentialEquations\nprob = ODEProblem(simplified_sys, x0, (0.0, 100.0), p)\nsol = solve(prob, Tsit5())\nsol[decay2.f]","category":"page"},{"location":"basics/Composition/#Basics-of-Model-Composition-1","page":"Composing Models and Building Reusable Components","title":"Basics of Model Composition","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Every AbstractSystem has a system keyword argument for specifying subsystems. A model is the composition of itself and its subsystems. For example, if we have:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"@named sys = ODESystem(eqs,indepvar,states,ps,system=[subsys])","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"the equations of sys is the concatenation of get_eqs(sys) and equations(subsys), the states are the concatenation of their states, etc. When the ODEProblem or ODEFunction is generated from this system, it will build and compile the functions associated with this composition.","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The new equations within the higher level system can access the variables in the lower level system by namespacing via the nameof(subsys). For example, let's say there is a variable x in states and a variable x in subsys. We can declare that these two variables are the same by specifying their equality: x ~ subsys.x in the eqs for sys. This algebraic relationship can then be simplified by transformations like structural_simplify which will be described later.","category":"page"},{"location":"basics/Composition/#Numerics-with-Composed-Models-1","page":"Composing Models and Building Reusable Components","title":"Numerics with Composed Models","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"These composed models can then be directly transformed into their associated SciMLProblem type using the standard constructors. When this is done, the initial conditions and parameters must be specified in their namespaced form. For example:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"u0 = [\n  x => 2.0\n  subsys.x => 2.0\n]","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Note that any default values within the given subcomponent will be used if no override is provided at construction time. If any values for initial conditions or parameters are unspecified an error will be thrown.","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"When the model is numerically solved, the solution can be accessed via its symbolic values. For example, if sol is the ODESolution, one can use sol[x] and sol[subsys.x] to access the respective timeseries in the solution. All other indexing rules stay the same, so sol[x,1:5] accesses the first through fifth values of x. Note that this can be done even if the variable x is eliminated from the system from transformations like alias_elimination or tearing: the variable will be lazily reconstructed on demand.","category":"page"},{"location":"basics/Composition/#Structural-Simplify-1","page":"Composing Models and Building Reusable Components","title":"Structural Simplify","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"In many cases, the nicest way to build a model may leave a lot of unnecessary variables. Thus one may want to remove these equations before numerically solving. The structural_simplify function removes these trivial equality relationships and trivial singularity equations, i.e. equations which result in 0~0 expressions, in over-specified systems.","category":"page"},{"location":"basics/Composition/#Inheritance-and-Combine-(TODO)-1","page":"Composing Models and Building Reusable Components","title":"Inheritance and Combine (TODO)","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Model inheritance can be done in two ways: explicitly or implicitly. The explicit way is to shadow variables with equality expressions. For example, let's assume we have three separate systems which we want to compose to a single one. This is how one could explicitly forward all states and parameters to the higher level system:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\n\n## Library code\n\n@parameters t\nD = Differential(t)\n\n@variables S(t), I(t), R(t)\nN = S + I + R\n@parameters β,γ\n\n@named seqn = ODESystem([D(S) ~ -β*S*I/N])\n@named ieqn = ODESystem([D(I) ~ β*S*I/N-γ*I])\n@named reqn = ODESystem([D(R) ~ γ*I])\n\n@named sir = ODESystem([   \n                    S ~ ieqn.S,\n                    I ~ seqn.I,\n                    R ~ ieqn.R,\n                    ieqn.S ~ seqn.S,\n                    seqn.I ~ ieqn.I,\n                    seqn.R ~ reqn.R,\n                    ieqn.R ~ reqn.R,\n                    reqn.I ~ ieqn.I], t, [S,I,R], [β,γ],\n                    systems=[seqn,ieqn,reqn],\n                    default_p = [\n                        seqn.β => β\n                        ieqn.β => β\n                        ieqn.γ => γ\n                        reqn.γ => γ\n                    ])","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Note that the states are forwarded by an equality relationship, while the parameters are forwarded through a relationship in their default values. The user of this model can then solve this model simply by specifying the values at the highest level:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"sireqn_simple = structural_simplify(sir)\n\nequations(sireqn_simple)\n\n# 3-element Vector{Equation}:\n#Differential(t)(seqn₊S(t)) ~ -seqn₊β*ieqn₊I(t)*seqn₊S(t)*(((ieqn₊I(t)) + (reqn₊R(t)) + (seqn₊S(t)))^-1)\n#Differential(t)(ieqn₊I(t)) ~ ieqn₊β*ieqn₊I(t)*seqn₊S(t)*(((ieqn₊I(t)) + (reqn₊R(t)) + (seqn₊S(t)))^-1) - (ieqn₊γ*(ieqn₊I(t)))\n#Differential(t)(reqn₊R(t)) ~ reqn₊γ*ieqn₊I(t)\n\n## User Code\n\nu0 = [seqn.S => 990.0,\n      ieqn.I => 10.0,\n      reqn.R => 0.0]\n\np = [\n    β => 0.5\n    γ => 0.25\n]\n\ntspan = (0.0,40.0)\nprob = ODEProblem(sireqn_simple,u0,tspan,p,jac=true)\nsol = solve(prob,Tsit5())\nsol[reqn.R]","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"However, one can similarly simplify this process of inheritance by using combine which concatenates all of the vectors within the systems. For example, we could equivalently have done:","category":"page"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"@named sir = combine([seqn,ieqn,reqn])","category":"page"},{"location":"basics/Composition/#Tearing-Problem-Construction-1","page":"Composing Models and Building Reusable Components","title":"Tearing Problem Construction","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Some system types, specifically ODESystem and NonlinearSystem, can be further reduced if structural_simplify has already been applied to them. This is done by using the alternative problem constructors, ODAEProblem and BlockNonlinearProblem respectively. In these cases, the constructor uses the knowledge of the strongly connected components calculated during the process of simplification as the basis for building pre-simplified nonlinear systems in the implicit solving. In summary: these problems are structurally modified, but could be more efficient and more stable.","category":"page"},{"location":"basics/Composition/#Automatic-Model-Promotion-(TODO)-1","page":"Composing Models and Building Reusable Components","title":"Automatic Model Promotion (TODO)","text":"","category":"section"},{"location":"basics/Composition/#","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"In many cases one might want to compose models of different types. For example, one may want to include a NonlinearSystem as a set of algebraic equations within an ODESystem, or one may want to use an ODESystem as a subsystem of an SDESystem. In these cases, the compostion works automatically by promoting the model via promote_system. System promotions exist in the cases where a mathematically-trivial definition of the promotion exists.","category":"page"},{"location":"basics/Validation/#Model-Validation-and-Units-1","page":"Model Validation and Units","title":"Model Validation and Units","text":"","category":"section"},{"location":"basics/Validation/#","page":"Model Validation and Units","title":"Model Validation and Units","text":"ModelingToolkit.jl provides extensive functionality for model validation and unit checking. This is done by providing metadata to the variable types and then running the validation functions which identify malformed systems and non-physical equations.","category":"page"},{"location":"basics/Validation/#Consistency-Checking-1","page":"Model Validation and Units","title":"Consistency Checking","text":"","category":"section"},{"location":"basics/Validation/#","page":"Model Validation and Units","title":"Model Validation and Units","text":"check_consistency","category":"page"},{"location":"basics/Validation/#Unit-and-Type-Validation-1","page":"Model Validation and Units","title":"Unit and Type Validation","text":"","category":"section"},{"location":"basics/Validation/#","page":"Model Validation and Units","title":"Model Validation and Units","text":"ModelingToolkit.validate","category":"page"},{"location":"systems/SDESystem/#SDESystem-1","page":"SDESystem","title":"SDESystem","text":"","category":"section"},{"location":"systems/SDESystem/#System-Constructors-1","page":"SDESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDESystem","category":"page"},{"location":"systems/SDESystem/#ModelingToolkit.SDESystem","page":"SDESystem","title":"ModelingToolkit.SDESystem","text":"struct SDESystem <: ModelingToolkit.AbstractODESystem\n\nA system of stochastic differential equations.\n\nFields\n\neqs\nThe expressions defining the drift term.\nnoiseeqs\nThe expressions defining the diffusion term.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\nobserved\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nSystems: the internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nnoiseeqs = [0.1*x,\n            0.1*y,\n            0.1*z]\n\nde = SDESystem(eqs,noiseeqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#Composition-and-Accessor-Functions-1","page":"SDESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"get_eqs(sys) or equations(sys): The equations that define the SDE.\nget_states(sys) or states(sys): The set of states in the SDE.\nget_ps(sys)s or parameters(sys): The parameters of the SDE.\nindependent_variable(sys): The independent variable of the SDE.","category":"page"},{"location":"systems/SDESystem/#Transformations-1","page":"SDESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"structural_simplify\r\nalias_elimination","category":"page"},{"location":"systems/SDESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"SDESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W\r\njacobian_sparsity","category":"page"},{"location":"systems/SDESystem/#Problem-Constructors-1","page":"SDESystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDEFunction\r\nSDEProblem","category":"page"},{"location":"systems/SDESystem/#SciMLBase.SDEFunction","page":"SDESystem","title":"SciMLBase.SDEFunction","text":"function DiffEqBase.SDEFunction{iip}(sys::SDESystem, dvs = sys.states, ps = sys.ps;\n                                     version = nothing, tgrad=false, sparse = false,\n                                     jac = false, Wfact = false, kwargs...) where {iip}\n\nCreate an SDEFunction from the SDESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#SciMLBase.SDEProblem","page":"SDESystem","title":"SciMLBase.SDEProblem","text":"function DiffEqBase.SDEProblem{iip}(sys::SDESystem,u0map,tspan,p=parammap;\n                                    version = nothing, tgrad=false,\n                                    jac = false, Wfact = false,\n                                    checkbounds = false, sparse = false,\n                                    sparsenoise = sparse,\n                                    skipzeros = true, fillzeros = true,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...)\n\nGenerates an SDEProblem from an SDESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Internal-Details-1","page":"Internal Details","title":"Internal Details","text":"","category":"section"},{"location":"internals/#","page":"Internal Details","title":"Internal Details","text":"This is a page for detailing some of the inner workings to help future contributors to the library.","category":"page"},{"location":"internals/#Observables-and-Variable-Elimination-1","page":"Internal Details","title":"Observables and Variable Elimination","text":"","category":"section"},{"location":"internals/#","page":"Internal Details","title":"Internal Details","text":"In the variable \"elimination\" algorithms, what is actually done is that variables are removed from being states and equations are moved into the observed category of the system. The observed equations are explicit algebraic equations which are then substituted out to completely eliminate these variables from the other equations, allowing the system to act as though these variables no longer exist.","category":"page"},{"location":"internals/#","page":"Internal Details","title":"Internal Details","text":"However, as a user may have wanted to interact with such variables, for example, plotting their output, these relationships are stored and are then used to generate the observed equation found in the SciMLFunction interface, so that sol[x] lazily reconstructs the observed variable when necessary. In this sense, there is an equivalence between observables and the variable elimination system.","category":"page"},{"location":"systems/PDESystem/#PDESystem-1","page":"PDESystem","title":"PDESystem","text":"","category":"section"},{"location":"systems/PDESystem/#","page":"PDESystem","title":"PDESystem","text":"PDESystem is still a work in progress.","category":"page"},{"location":"tutorials/modelingtoolkitize/#Symbolic-Extensions-to-ODEProblem-via-Modelingtoolkitize-1","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"For some DEProblem types, automatic tracing functionality is already included via the modelingtoolkitize function. Take, for example, the Robertson ODE defined as an ODEProblem for DifferentialEquations.jl:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"using DifferentialEquations\r\nfunction rober(du,u,p,t)\r\n  y₁,y₂,y₃ = u\r\n  k₁,k₂,k₃ = p\r\n  du[1] = -k₁*y₁+k₃*y₂*y₃\r\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\r\n  du[3] =  k₂*y₂^2\r\n  nothing\r\nend\r\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"If we want to get a symbolic representation, we can simply call modelingtoolkitize on the prob, which will return an ODESystem:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"sys = modelingtoolkitize(prob)","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"Using this, we can symbolically build the Jacobian and then rebuild the ODEProblem:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"jac = eval(ModelingToolkit.generate_jacobian(sys)[2])\r\nf = ODEFunction(rober, jac=jac)\r\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"systems/OptimizationSystem/#OptimizationSystem-1","page":"OptimizationSystem","title":"OptimizationSystem","text":"","category":"section"},{"location":"systems/OptimizationSystem/#System-Constructors-1","page":"OptimizationSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationSystem","category":"page"},{"location":"systems/OptimizationSystem/#ModelingToolkit.OptimizationSystem","page":"OptimizationSystem","title":"ModelingToolkit.OptimizationSystem","text":"struct OptimizationSystem <: ModelingToolkit.AbstractSystem\n\nA scalar equation for optimization.\n\nFields\n\nop\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nobserved\nequality_constraints\ninequality_constraints\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\nop = σ*(y-x) + x*(ρ-z)-y + x*y - β*z\nos = OptimizationSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/OptimizationSystem/#Composition-and-Accessor-Functions-1","page":"OptimizationSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"get_eqs(sys) or equations(sys): The equation to be minimized.\nget_states(sys) or states(sys): The set of states for the optimization.\nget_ps(sys) or parameters(sys): The parameters for the optimization.","category":"page"},{"location":"systems/OptimizationSystem/#Transformations-1","page":"OptimizationSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/OptimizationSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"OptimizationSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"calculate_gradient\r\ncalculate_hessian\r\ngenerate_gradient\r\ngenerate_hessian\r\nhessian_sparsity","category":"page"},{"location":"systems/OptimizationSystem/#Problem-Constructors-1","page":"OptimizationSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationProblem","category":"page"},{"location":"systems/OptimizationSystem/#SciMLBase.OptimizationProblem","page":"OptimizationSystem","title":"SciMLBase.OptimizationProblem","text":"function DiffEqBase.OptimizationProblem{iip}(sys::OptimizationSystem,\n                                          parammap=DiffEqBase.NullParameters();\n                                          u0=nothing, lb=nothing, ub=nothing,\n                                          grad = false,\n                                          hess = false, sparse = false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an OptimizationProblem from an OptimizationSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/higher_order/#Automatic-Transformation-of-Nth-Order-ODEs-to-1st-Order-ODEs-1","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"","category":"section"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"ModelingToolkit has a system for transformations of mathematical systems. These transformations allow for symbolically changing the representation of the model to problems that are easier to numerically solve. One simple to demonstrate transformation is the ode_order_lowering transformation that sends an Nth order ODE to a 1st order ODE.","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"To see this, let's define a second order riff on the Lorenz equations. We utilize the derivative operator twice here to define the second order:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"using ModelingToolkit, OrdinaryDiffEq\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)\r\n\r\neqs = [D(D(x)) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]\r\n\r\nsys = ODESystem(eqs)","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Note that we could've used an alternative syntax for 2nd order, i.e. D = Differential(t)^2 and then E(x) would be the second derivative, and this syntax extends to N-th order. Also, we can use * or ∘ to compose Differentials, like Differential(t) * Differential(x).","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now let's transform this into the ODESystem of first order components. We do this by simply calling ode_order_lowering:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"sys = ode_order_lowering(sys)","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now we can directly numerically solve the lowered system. Note that, following the original problem, the solution requires knowing the initial condition for x', and thus we include that in our input specification:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"u0 = [D(x) => 2.0,\r\n      x => 1.0,\r\n      y => 0.0,\r\n      z => 0.0]\r\n\r\np  = [σ => 28.0,\r\n      ρ => 10.0,\r\n      β => 8/3]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(sys,u0,tspan,p,jac=true)\r\nsol = solve(prob,Tsit5())\r\nusing Plots; plot(sol,vars=(x,y))","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"(Image: Lorenz2)","category":"page"},{"location":"systems/ODESystem/#ODESystem-1","page":"ODESystem","title":"ODESystem","text":"","category":"section"},{"location":"systems/ODESystem/#System-Constructors-1","page":"ODESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODESystem","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ODESystem","page":"ODESystem","title":"ModelingToolkit.ODESystem","text":"struct ODESystem <: ModelingToolkit.AbstractODESystem\n\nA system of ordinary differential equations.\n\nFields\n\neqs\nThe ODEs defining the system.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\nobserved\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems. These are required to have unique names.\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nstructure\nstructure: structural information of the system\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nde = ODESystem(eqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#Composition-and-Accessor-Functions-1","page":"ODESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"get_eqs(sys) or equations(sys): The equations that define the ODE.\nget_states(sys) or states(sys): The set of states in the ODE.\nget_ps(sys) or parameters(sys): The parameters of the ODE.\nindependent_variable(sys): The independent variable of the ODE.","category":"page"},{"location":"systems/ODESystem/#Transformations-1","page":"ODESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"structural_simplify\r\node_order_lowering\r\ndae_index_lowering\r\nliouville_transform\r\nalias_elimination\r\ntearing","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ode_order_lowering","page":"ODESystem","title":"ModelingToolkit.ode_order_lowering","text":"ode_order_lowering(sys::ODESystem) -> ODESystem\n\n\nTakes a Nth order ODESystem and returns a new ODESystem written in first order form by defining new variables which represent the N-1 derivatives.\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#ModelingToolkit.StructuralTransformations.dae_index_lowering","page":"ODESystem","title":"ModelingToolkit.StructuralTransformations.dae_index_lowering","text":"dae_index_lowering(sys::ODESystem) -> ODESystem\n\nPerform the Pantelides algorithm to transform a higher index DAE to an index 1 DAE.\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#ModelingToolkit.liouville_transform","page":"ODESystem","title":"ModelingToolkit.liouville_transform","text":"liouville_transform(sys::Any) -> ODESystem\n\n\nGenerates the Liouville transformed set of ODEs, which is the original ODE system with a new variable trJ appended, corresponding to the -tr(Jacobian). This variable is used for properties like uncertainty propagation from a given initial distribution density.\n\nFor example, if u=p*u and p follows a probability distribution f(p), then the probability density of a future value with a given choice of p is computed by setting the inital trJ = f(p), and the final value of trJ is the probability of u(t).\n\nExample:\n\nusing ModelingToolkit, OrdinaryDiffEq, Test\n\n@parameters t α β γ δ\n@variables x(t) y(t)\nD = Differential(t)\n\neqs = [D(x) ~ α*x - β*x*y,\n       D(y) ~ -δ*y + γ*x*y]\n\nsys = ODESystem(eqs)\nsys2 = liouville_transform(sys)\n@variables trJ\n\nu0 = [x => 1.0,\n      y => 1.0,\n      trJ => 1.0]\n\nprob = ODEProblem(sys2,u0,tspan,p)\nsol = solve(prob,Tsit5())\n\nWhere sol[3,:] is the evolution of trJ over time.\n\nSources:\n\nProbabilistic Robustness Analysis of F-16 Controller Performance: An Optimal Transport Approach\n\nAbhishek Halder, Kooktae Lee, and Raktim Bhattacharya https://abhishekhalder.bitbucket.io/F16ACC2013Final.pdf\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"ODESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W\r\njacobian_sparsity","category":"page"},{"location":"systems/ODESystem/#Standard-Problem-Constructors-1","page":"ODESystem","title":"Standard Problem Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODEFunction\r\nODEProblem","category":"page"},{"location":"systems/ODESystem/#SciMLBase.ODEFunction","page":"ODESystem","title":"SciMLBase.ODEFunction","text":"function DiffEqBase.ODEFunction{iip}(sys::AbstractODESystem, dvs = states(sys),\n                                     ps = parameters(sys);\n                                     version = nothing, tgrad=false,\n                                     jac = false,\n                                     sparse = false,\n                                     kwargs...) where {iip}\n\nCreate an ODEFunction from the ODESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#SciMLBase.ODEProblem","page":"ODESystem","title":"SciMLBase.ODEProblem","text":"function DiffEqBase.ODEProblem{iip}(sys::AbstractODESystem,u0map,tspan,\n                                    parammap=DiffEqBase.NullParameters();\n                                    version = nothing, tgrad=false,\n                                    jac = false,\n                                    checkbounds = false, sparse = false,\n                                    simplify=false,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...) where iip\n\nGenerates an ODEProblem from an ODESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#Torn-Problem-Constructors-1","page":"ODESystem","title":"Torn Problem Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODAEProblem","category":"page"},{"location":"basics/DependencyGraphs/#Dependency-Graphs-1","page":"Dependency Graphs","title":"Dependency Graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Types-1","page":"Dependency Graphs","title":"Types","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"BipartiteGraph","category":"page"},{"location":"basics/DependencyGraphs/#ModelingToolkit.BipartiteGraphs.BipartiteGraph","page":"Dependency Graphs","title":"ModelingToolkit.BipartiteGraphs.BipartiteGraph","text":"mutable struct BipartiteGraph{I<:Integer, M} <: LightGraphs.AbstractGraph{I<:Integer}\n\nA bipartite graph representation between two, possibly distinct, sets of vertices (source and dependencies). Maps source vertices, labelled 1:N₁, to vertices on which they depend (labelled 1:N₂).\n\nFields\n\nne\nfadjlist\nbadjlist\nmetadata\n\nExample\n\nusing ModelingToolkit\n\nne = 4\nsrcverts = 1:4\ndepverts = 1:2\n\n# six source vertices\nfadjlist = [[1],[1],[2],[2],[1],[1,2]]\n\n# two vertices they depend on\nbadjlist = [[1,2,5,6],[3,4,6]]\n\nbg = BipartiteGraph(7, fadjlist, badjlist)\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Utility-functions-for-BiPartiteGraphs-1","page":"Dependency Graphs","title":"Utility functions for BiPartiteGraphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"Base.isequal","category":"page"},{"location":"basics/DependencyGraphs/#Base.isequal","page":"Dependency Graphs","title":"Base.isequal","text":"Base.isequal(bg1::BipartiteGraph{T}, bg2::BipartiteGraph{T}) where {T<:Integer}\n\nTest whether two BipartiteGraphs are equal.\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#Functions-for-calculating-dependency-graphs-1","page":"Dependency Graphs","title":"Functions for calculating dependency graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"equation_dependencies\nasgraph\nvariable_dependencies\nasdigraph\neqeq_dependencies\nvarvar_dependencies","category":"page"},{"location":"basics/DependencyGraphs/#ModelingToolkit.equation_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.equation_dependencies","text":"equation_dependencies(sys::AbstractSystem; variables=states(sys))\n\nGiven an AbstractSystem calculate for each equation the variables it depends on.\n\nNotes:\n\nVariables that are not in variables are filtered out.\nget_variables! is used to determine the variables within a given equation.\nreturns a Vector{Vector{Variable}}() mapping the index of an equation to the variables it depends on.\n\nExample:\n\nusing ModelingToolkit\n@parameters β γ κ η t\n@variables S(t) I(t) R(t)\n\n# use a reaction system to easily generate ODE and jump systems\nrxs = [Reaction(β, [S,I], [I], [1,1], [2]),\n       Reaction(γ, [I], [R]),\n       Reaction(κ+η, [R], [S])]\nrs = ReactionSystem(rxs, t, [S,I,R], [β,γ,κ,η])\n\n# ODEs:\nodesys = convert(ODESystem, rs)\n\n# dependency of each ODE on state variables\nequation_dependencies(odesys)\n\n# dependency of each ODE on parameters\nequation_dependencies(odesys, variables=parameters(odesys))\n\n# Jumps\njumpsys = convert(JumpSystem, rs)\n\n# dependency of each jump rate function on state variables\nequation_dependencies(jumpsys)\n\n# dependency of each jump rate function on parameters\nequation_dependencies(jumpsys, variables=parameters(jumpsys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asgraph","page":"Dependency Graphs","title":"ModelingToolkit.asgraph","text":"asgraph(eqdeps, vtois)\n\nConvert a collection of equation dependencies, for example as returned by equation_dependencies, to a BipartiteGraph.\n\nNotes:\n\nvtois should provide a Dict like mapping from each Variable dependency in eqdeps to the integer idx of the variable to use in the graph.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(equation_dependencies(odesys), Dict(s => i for (i,s) in enumerate(states(odesys))))\n\n\n\n\n\nasgraph(sys::AbstractSystem; variables=states(sys),\n                                      variablestoids=Dict(convert(Variable, v) => i for (i,v) in enumerate(variables)))\n\nConvert an AbstractSystem to a BipartiteGraph mapping the index of equations to the indices of variables they depend on.\n\nNotes:\n\nDefaults for kwargs creating a mapping from equations(sys) to states(sys) they depend on.\nvariables should provide the list of variables to use for generating the dependency graph.\nvariablestoids should provide Dict like mapping from a Variable to its Int index within variables.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(odesys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.variable_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.variable_dependencies","text":"variable_dependencies(sys::AbstractSystem; variables=states(sys), variablestoids=nothing)\n\nFor each variable determine the equations that modify it and return as a BipartiteGraph.\n\nNotes:\n\nDependencies are returned as a BipartiteGraph mapping variable indices to the indices of equations that modify them.\nvariables denotes the list of variables to determine dependencies for.\nvariablestoids denotes a Dict mapping Variables to their Int index in variables.\n\nExample: Continuing the example of equation_dependencies\n\nvariable_dependencies(odesys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asdigraph","page":"Dependency Graphs","title":"ModelingToolkit.asdigraph","text":"asdigraph(g::BipartiteGraph, sys::AbstractSystem; variables = states(sys), equationsfirst = true)\n\nConvert a BipartiteGraph to a LightGraph.SimpleDiGraph.\n\nNotes:\n\nThe resulting SimpleDiGraph unifies the two sets of vertices (equations and then states in the case it comes from asgraph), producing one ordered set of integer vertices (SimpleDiGraph does not support two distinct collections of vertices so they must be merged).\nvariables gives the variables that g is associated with (usually the states of a system).\nequationsfirst (default is true) gives whether the BipartiteGraph gives a mapping from equations to variables they depend on (true), as calculated by asgraph, or whether it gives a mapping from variables to the equations that modify them, as calculated by variable_dependencies.\n\nExample: Continuing the example in asgraph\n\ndg = asdigraph(digr)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.eqeq_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.eqeq_dependencies","text":"eqeq_dependencies(eqdeps::BipartiteGraph{T}, vardeps::BipartiteGraph{T}) where {T <: Integer}\n\nCalculate a LightGraph.SimpleDiGraph that maps each equation to equations they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from an equation to the equations that modify variables it depends on.\nThe badjlist of the SimpleDiGraph maps from an equation to equations that depend on variables it modifies.\n\nExample: Continuing the example of equation_dependencies\n\neqeqdep = eqeq_dependencies(asgraph(odesys), variable_dependencies(odesys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.varvar_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.varvar_dependencies","text":"varvar_dependencies(eqdeps::BipartiteGraph{T}, vardeps::BipartiteGraph{T}) where {T <: Integer} = eqeq_dependencies(vardeps, eqdeps)\n\nCalculate a LightGraph.SimpleDiGraph that maps each variable to variables they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from a variable to the variables that depend on it.\nThe badjlist of the SimpleDiGraph maps from a variable to variables on which it depends.\n\nExample: Continuing the example of equation_dependencies\n\nvarvardep = varvar_dependencies(asgraph(odesys), variable_dependencies(odesys))\n\n\n\n\n\n","category":"function"},{"location":"tutorials/nonlinear/#Solving-Nonlinear-Systems-with-NLsolve-1","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"","category":"section"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"In this example we will go one step deeper and showcase the direct function generation capabilities in ModelingToolkit.jl to build nonlinear systems. Let's say we wanted to solve for the steady state of the previous ODE. This is the nonlinear system defined by where the derivatives are zero. We use (unknown) variables for our nonlinear system.","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"using ModelingToolkit\r\n\r\n@variables x y z\r\n@parameters σ ρ β\r\n\r\n# Define a nonlinear system\r\neqs = [0 ~ σ*(y-x),\r\n       0 ~ x*(ρ-z)-y,\r\n       0 ~ x*y - β*z]\r\nns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\r\nnlsys_func = generate_function(ns)[2] # second is the inplace version","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which generates:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"(var\"##MTIIPVar#405\", u, p)->begin\r\n        @inbounds begin\r\n                @inbounds begin\r\n                        let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                            var\"##MTIIPVar#405\"[1] = (*)(σ, (-)(y, x))\r\n                            var\"##MTIIPVar#405\"[2] = (-)((*)(x, (-)(ρ, z)), y)\r\n                            var\"##MTIIPVar#405\"[3] = (-)((*)(x, y), (*)(β, z))\r\n                        end\r\n                    end\r\n            end\r\n        nothing\r\n    end","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"We can use this to build a nonlinear function for use with NLsolve.jl:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"f = eval(nlsys_func)\r\ndu = zeros(3); u = ones(3)\r\nparams = (10.0,26.0,2.33)\r\nf(du,u,params)\r\ndu\r\n\r\n#=\r\n3-element Array{Float64,1}:\r\n  0.0\r\n 24.0\r\n -1.33\r\n =#","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"We can similarly ask to generate the in-place Jacobian function:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"j_func = generate_jacobian(ns)[2] # second is in-place\r\nj! = eval(j_func)","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which gives:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":":((var\"##MTIIPVar#582\", u, p)->begin\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:70 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =# @inbounds begin\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:72 =#\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =# @inbounds begin\r\n                          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =#\r\n                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                              var\"##MTIIPVar#582\"[1] = (*)(σ, -1)\r\n                              var\"##MTIIPVar#582\"[2] = (-)(ρ, z)\r\n                              var\"##MTIIPVar#582\"[3] = y\r\n                              var\"##MTIIPVar#582\"[4] = σ\r\n                              var\"##MTIIPVar#582\"[5] = -1\r\n                              var\"##MTIIPVar#582\"[6] = x\r\n                              var\"##MTIIPVar#582\"[7] = 0\r\n                              var\"##MTIIPVar#582\"[8] = (*)(x, -1)\r\n                              var\"##MTIIPVar#582\"[9] = (*)(-1, β)\r\n                          end\r\n                      end\r\n              end\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:74 =#\r\n          nothing\r\n      end)","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"Now, we can call nlsolve by enclosing our parameters into the functions:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"using NLsolve\r\nnlsolve((out, x) -> f(out, x, params), (out, x) -> j!(out, x, params), ones(3))","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"If one would like the generated function to be a Julia function instead of an expression, and allow this function to be used from within the same world-age, one simply needs to pass Val{false} to tell it to generate the function, i.e.:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"nlsys_func = generate_function(ns, [x,y,z], [σ,ρ,β], expression=Val{false})[2]","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which uses RuntimeGeneratedFunctions.jl to build the same world-age function on the fly without eval.","category":"page"},{"location":"systems/JumpSystem/#JumpSystem-1","page":"JumpSystem","title":"JumpSystem","text":"","category":"section"},{"location":"systems/JumpSystem/#System-Constructors-1","page":"JumpSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"JumpSystem","category":"page"},{"location":"systems/JumpSystem/#ModelingToolkit.JumpSystem","page":"JumpSystem","title":"ModelingToolkit.JumpSystem","text":"struct JumpSystem{U<:RecursiveArrayTools.ArrayPartition} <: ModelingToolkit.AbstractSystem\n\nA system of jump processes.\n\nFields\n\neqs\nThe jumps of the system. Allowable types are ConstantRateJump, VariableRateJump, MassActionJump.\n\niv\nThe independent variable, usually time.\nstates\nThe dependent variables, representing the state of the system.\nps\nThe parameters of the system.\nobserved\nname\nThe name of the system.\nsystems\nThe internal systems.\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@parameters β γ t\n@variables S I R\nrate₁   = β*S*I\naffect₁ = [S ~ S - 1, I ~ I + 1]\nrate₂   = γ*I\naffect₂ = [I ~ I - 1, R ~ R + 1]\nj₁      = ConstantRateJump(rate₁,affect₁)\nj₂      = ConstantRateJump(rate₂,affect₂)\nj₃      = MassActionJump(2*β+γ, [R => 1], [S => 1, R => -1])\njs      = JumpSystem([j₁,j₂,j₃], t, [S,I,R], [β,γ])\n\n\n\n\n\n","category":"type"},{"location":"systems/JumpSystem/#Composition-and-Accessor-Functions-1","page":"JumpSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"get_eqs(sys) or equations(sys): The equations that define the jump system.\nget_states(sys) or states(sys): The set of states in the jump system.\nget_ps(sys) or parameters(sys): The parameters of the jump system.\nindependent_variable(sys): The independent variable of the jump system.","category":"page"},{"location":"systems/JumpSystem/#Transformations-1","page":"JumpSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"structural_simplify","category":"page"},{"location":"systems/JumpSystem/#Problem-Constructors-1","page":"JumpSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"DiscreteProblem\nJumpProblem","category":"page"},{"location":"systems/JumpSystem/#SciMLBase.DiscreteProblem","page":"JumpSystem","title":"SciMLBase.DiscreteProblem","text":"function DiffEqBase.DiscreteProblem(sys::JumpSystem, u0map, tspan,\n                                    parammap=DiffEqBase.NullParameters; kwargs...)\n\nGenerates a blank DiscreteProblem for a pure jump JumpSystem to utilize as its prob.prob. This is used in the case where there are no ODEs and no SDEs associated with the system.\n\nContinuing the example from the JumpSystem definition:\n\nusing DiffEqBase, DiffEqJump\nu₀map = [S => 999, I => 1, R => 0]\nparammap = [β => .1/1000, γ => .01]\ntspan = (0.0, 250.0)\ndprob = DiscreteProblem(js, u₀map, tspan, parammap)\n\n\n\n\n\n","category":"type"},{"location":"systems/JumpSystem/#DiffEqJump.JumpProblem","page":"JumpSystem","title":"DiffEqJump.JumpProblem","text":"function DiffEqBase.JumpProblem(js::JumpSystem, prob, aggregator; kwargs...)\n\nGenerates a JumpProblem from a JumpSystem.\n\nContinuing the example from the DiscreteProblem definition:\n\njprob = JumpProblem(js, dprob, Direct())\nsol = solve(jprob, SSAStepper())\n\n\n\n\n\n","category":"type"},{"location":"basics/ContextualVariables/#Contextual-Variable-Types-1","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"ModelingToolkit.jl has a system of contextual variable types which allows for helping the system transformation machinery do complex manipulations and automatic detection. The standard variable definition in ModelingToolkit.jl is the @variable which is defined by Symbolics.jl. For example:","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variabes x y(x)","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"This is used for the \"normal\" variable of a given system, like the states of a differential equation or objective function. All of the macros below support the same syntax as @variables.","category":"page"},{"location":"basics/ContextualVariables/#Parameters-1","page":"Contextual Variable Types","title":"Parameters","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"All modeling projects have some form of parameters. @parameters marks a variable as being the parameter of some system, which allows automatic detection algorithms to ignore such variables when attempting to find the states of a system.","category":"page"},{"location":"basics/ContextualVariables/#Flow-Variables-(TODO)-1","page":"Contextual Variable Types","title":"Flow Variables (TODO)","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"In many engineering systems some variables act like \"flows\" while others do not. For example, in circuit models you have current which flows, and the related voltage which does not. Or in thermal models you have heat flows. In these cases, the connect statement enforces conservation of flow between all of the connected components.","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"For example, the following specifies that x is a 2x2 matrix of flow variables:","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variables x[1:2,1:2] type=flow","category":"page"},{"location":"basics/ContextualVariables/#Stream-Variables-1","page":"Contextual Variable Types","title":"Stream Variables","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"TODO","category":"page"},{"location":"basics/ContextualVariables/#Brownian-Variables-1","page":"Contextual Variable Types","title":"Brownian Variables","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"TODO","category":"page"},{"location":"#ModelingToolkit.jl:-High-Performance-Symbolic-Numeric-Equation-Based-Modeling-1","page":"Home","title":"ModelingToolkit.jl: High-Performance Symbolic-Numeric Equation-Based Modeling","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl is a modeling language for high-performance symbolic-numeric computation in scientific computing and scientific machine learning. It then mixes ideas from symbolic computational algebra systems with causal and acausal equation-based modeling frameworks to give an extendable and parallel modeling system. It allows for users to give a high-level description of a model for symbolic preprocessing to analyze and enhance the model. Automatic transformations, such as index reduction, can be applied to the model before solving in order to make it easily handle equations would could not be solved when modeled without symbolic intervention.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install ModelingToolkit.jl, use the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelingToolkit\")","category":"page"},{"location":"#Feature-Summary-1","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl is a symbolic-numeric modeling package. Thus it combines some of the features from symbolic computing packages like SymPy or Mathematica with the ideas of equation-based modeling systems like the causal Simulink and the acausal Modelica. It bridges the gap between many different kinds of equations, allowing one to quickly and easily transform systems of DAEs into optimization problems, or vice-versa, and then simplify and parallelize the resulting expressions before generating code.","category":"page"},{"location":"#Feature-List-1","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Causal and acausal modeling (Simulink/Modelica)\nAutomated model transformation, simplification, and composition\nAutomatic conversion of numerical models into symbolic models\nComposition of models through the components, a lazy connection system, and tools for expanding/flattening\nPervasive parallelism in symbolic computations and generated functions\nTransformations like alias elimination and tearing of nonlinear systems for efficiently numerically handling large-scale systems of equations\nThe ability to use the entire Symbolics.jl Computer Algebra System (CAS) as part of the modeling process.\nImport models from common formats like SBML, CellML, BioNetGen, and more.\nExtendability: the whole system is written in pure Julia, so adding new functions, simplification rules, and model transformations has no barrier.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For information on how to use the Symbolics.jl CAS system that ModelingToolkit.jl is built on, consult the Symbolics.jl documentation","category":"page"},{"location":"#Equation-Types-1","page":"Home","title":"Equation Types","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ordinary differential equations\nStochastic differential equations\nPartial differential equations\nNonlinear systems\nOptimization problems\nContinuous-Time Markov Chains\nChemical Reactions\nOptimal Control","category":"page"},{"location":"#Extension-Libraries-1","page":"Home","title":"Extension Libraries","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Because ModelingToolkit.jl is the core foundation of a equation-based modeling ecosystem, there is a large set of libraries adding features to this system. Below is an incomplete list of extension libraries one may want to be aware of:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"StructuralTransformations.jl: Various transformations of models into structurally better versions for improved numerical simulation\nPantelides algortihm for index reduction of DAEs\nTearing of ODESystems and NonolinearSystems to reduce the numerical cost of handling large implicit systems via Newton methods\nCatalyst.jl: Symbolic representations of chemical reactions\nSymbolically build and represent large systems of chemical reactions\nGenerate code for ODEs, SDEs, continuous-time Markov Chains, and more\nSimulate the models using the SciML ecosystem with O(1) Gillespie methods\nDataDrivenDiffEq.jl: Automatic identification of equations from data\nAutomated construction of ODEs and DAEs from data\nRepresentations of Koopman operators and Dynamic Mode Decomposition (DMD)\nMomentClosure.jl: Automatic transformation of ReactionSystems into deterministic systems\nGenerates ODESystems for the moment closures\nAllows for geometrically-distributed random reaction rates\nReactionMechanismSimulator.jl: simulating and analyzing large chemical reaction mechanisms\nIdeal gas and dilute liquid phases.\nConstant T and P and constant V adiabatic ideal gas reactors.\nConstant T and V dilute liquid reactors.\nDiffusion limited rates. Sensitivity analysis for all reactors.\nFlux diagrams with molecular images (if molecular information is provided).","category":"page"},{"location":"#Model-Import-Formats-1","page":"Home","title":"Model Import Formats","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CellMLToolkit.jl: Import CellML models into ModelingToolkit\nRepository of more than a thousand pre-made models\nFocus on biomedical models in areas such as: Calcium Dynamics, Cardiovascular Circulation, Cell Cycle, Cell Migration, Circadian Rhythms, Electrophysiology, Endocrine, Excitation-Contraction Coupling, Gene Regulation, Hepatology, Immunology, Ion Transport, Mechanical Constitutive Laws, Metabolism, Myofilament Mechanics, Neurobiology, pH Regulation, PKPD, Protein Modules, Signal Transduction, and Synthetic Biology.\nSbmlInterface.jl: Import SBML models into ModelingToolkit\nUses the robust libsbml library for parsing and transforming the SBML\nReactionNetworkImporters.jl: Import various models into ModelingToolkit\nSupports the BioNetGen .net file\nSupports importing networks specified by stoichiometric matrices","category":"page"},{"location":"#Compatible-Numerical-Solvers-1","page":"Home","title":"Compatible Numerical Solvers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All of the symbolic systems have a direct conversion to a numerical system which can then be handled through the SciML interfaces. For example, after building a model and performing symbolic manipulations, an ODESystem can be converted into an ODEProblem to then be solved by a numerical ODE solver. Below is a list of the solver libraries which are the numerical targets of the ModelingToolkit system:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DifferentialEquations.jl\nMulti-package interface of high performance numerical solvers for ODESystem, SDESystem, and JumpSystem\nNonlinearSolve.jl\nHigh performance numerical solving of NonlinearSystem\nGalacticOptim.jl\nMulti-package interface for numerical solving OptimizationSystem\nNeuralPDE.jl\nPhysics-Informed Neural Network (PINN) training on PDESystem\nDiffEqOperators.jl\nAutomated finite difference method (FDM) discretization of PDESystem","category":"page"}]
}
