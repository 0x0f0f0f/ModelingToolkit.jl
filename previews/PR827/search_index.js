var documenterSearchIndex = {"docs":
[{"location":"basics/AbstractSystem/#The-AbstractSystem-Interface-1","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"","category":"section"},{"location":"basics/AbstractSystem/#Overview-1","page":"The AbstractSystem Interface","title":"Overview","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The AbstractSystem interface is the core of the system level of ModelingToolkit.jl. It establishes a common set of functionality that is used between systems from ODEs and chemical reactions, allowing users to have a common framework for model manipulation and compilation.","category":"page"},{"location":"basics/AbstractSystem/#Constructors-and-Naming-1","page":"The AbstractSystem Interface","title":"Constructors and Naming","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The AbstractSystem interface has a consistent method for constructing systems. Generally it follows the order of:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Equations\nIndependent Variables\nDependent Variables (or States)\nParameters","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"All other pieces are handled via keyword arguments. AbstractSystems share the same keyword arguments, which are:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"system: This is used for specifying subsystems for hierarchical modeling with reusable components. For more information, see the components page\nDefaults: Keyword arguments like default_u0 are used for specifying default values which are used. If a value is not given at the SciMLProblem construction time, its numerical value will be the default.","category":"page"},{"location":"basics/AbstractSystem/#Composition-and-Accessor-Functions-1","page":"The AbstractSystem Interface","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Each AbstractSystem has lists of variables in context, such as distinguishing parameters vs states. In addition, an AbstractSystem also can hold other AbstractSystem types. Direct accessing of the values, such as sys.states, gives the immediate list, while the accessor functions states(sys) gives the total set, which includes that of all systems held inside.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The values which are common to all AbstractSystems are:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"equations(sys): All equations that define the system and its subsystems.\nstates(sys): All the states in the system and its subsystems.\nparameters(sys): All parameters of the system and its subsystems.\nnameof(sys): The name of the current-level system.\nget_eqs(sys): Equations that define the current-level system.\nget_states(sys): States that are in the current-level system.\nget_ps(sys): Parameters that are in the current-level system.\nget_systems(sys): Subsystems of the current-level system.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Optionally, a system could have:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"observed(sys): All observed equations of the system and its subsystems.\nget_observed(sys): Observed equations of the current-level system.\nget_default_u0(sys): A Dict that maps states into their default initial condition.\nget_default_p(sys): A Dict that maps parameters into their default value.\nindependent_variable(sys): The independent variable of a system.\nget_noiseeqs(sys): Noise equations of the current-level system.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Note that there's get_iv(sys), but it is not advised to use, since it errors when the system has no field iv. independent_variable(sys) returns nothing for NonlinearSystems.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"A system could also have caches:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"get_jac(sys): The Jacobian of a system.\nget_tgrad(sys): The gradient with respect to time of a system.","category":"page"},{"location":"basics/AbstractSystem/#Transformations-1","page":"The AbstractSystem Interface","title":"Transformations","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Transformations are functions which send a valid AbstractSystem definition to another AbstractSystem. These are passes, like optimizations (e.g., Block-Lower Triangle transformations), or changes to the representation, which allow for alternative numerical methods to be utilized on the model (e.g., DAE index reduction).","category":"page"},{"location":"basics/AbstractSystem/#Function-Calculation-and-Generation-1","page":"The AbstractSystem Interface","title":"Function Calculation and Generation","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"The calculation and generation functions allow for calculating additional quantities to enhance the numerical methods applied to the resulting system. The calculations, like calculate_jacobian, generate ModelingToolkit IR for the Jacobian of the system, while the generations, like generate_jacobian, generate compiled output for the numerical solvers by applying build_function to the generated code. Additionally, many systems have function-type outputs, which cobble together the generation functionality for a system, for example, ODEFunction can be used to generate a DifferentialEquations-based ODEFunction with compiled version of the ODE itself, the Jacobian, the mass matrix, etc.","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Below are the possible calculation and generation functions:","category":"page"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"calculate_tgrad\ncalculate_gradient\ncalculate_jacobian\ncalculate_factorized_W\ncalculate_hessian\ngenerate_tgrad\ngenerate_gradient\ngenerate_jacobian\ngenerate_factorized_W\ngenerate_hessian","category":"page"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_tgrad","text":"calculate_tgrad(sys::AbstractSystem)\n\nCalculate the time gradient of a system.\n\nReturns a vector of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_gradient","text":"calculate_gradient(sys::AbstractSystem)\n\nCalculate the gradient of a scalar system.\n\nReturns a vector of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_jacobian","text":"calculate_jacobian(sys::AbstractSystem)\n\nCalculate the jacobian matrix of a system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_factorized_W","text":"calculate_factorized_W(sys::AbstractSystem)\n\nCalculate the factorized W-matrix of a system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.calculate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.calculate_hessian","text":"calculate_hessian(sys::AbstractSystem)\n\nCalculate the hessian matrix of a scalar system.\n\nReturns a matrix of Num instances. The result from the first call will be cached in the system object.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_tgrad","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_tgrad","text":"generate_tgrad(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the time gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_gradient","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_gradient","text":"generate_gradient(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; kwargs...)\n\nGenerates a function for the gradient of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_jacobian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_jacobian","text":"generate_jacobian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the jacobian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_factorized_W","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_factorized_W","text":"generate_factorized_W(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the factorized W-matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#ModelingToolkit.generate_hessian","page":"The AbstractSystem Interface","title":"ModelingToolkit.generate_hessian","text":"generate_hessian(sys::AbstractSystem, dvs = states(sys), ps = parameters(sys), expression = Val{true}; sparse = false, kwargs...)\n\nGenerates a function for the hessian matrix matrix of a system. Extra arguments control the arguments to the internal build_function call.\n\n\n\n\n\n","category":"function"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"Additionally, jacobian_sparsity(sys) and hessian_sparsity(sys) exist on the appropriate systems for fast generation of the sparsity patterns via an abstract interpretation without requiring differentiation.","category":"page"},{"location":"basics/AbstractSystem/#Problem-Constructors-1","page":"The AbstractSystem Interface","title":"Problem Constructors","text":"","category":"section"},{"location":"basics/AbstractSystem/#","page":"The AbstractSystem Interface","title":"The AbstractSystem Interface","text":"At the end, the system types have DEProblem constructors, like ODEProblem, which allow for directly generating the problem types required for numerical methods. The first argument is always the AbstractSystem, and the proceeding arguments match the argument order of their original constructors. Whenever an array would normally be provided, such as u0 the initial condition of an ODEProblem, it is instead replaced with a variable map, i.e., an array of pairs var=>value, which allows the user to designate the values without having to know the order that ModelingToolkit is internally using.","category":"page"},{"location":"systems/ReactionSystem/#ReactionSystem-1","page":"ReactionSystem","title":"ReactionSystem","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"A ReactionSystem represents a system of chemical reactions. Conversions are provided to generate corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models. As a simple example, the code below creates a SIR model, and solves the corresponding ODE, SDE, and jump process models.","category":"page"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"using ModelingToolkit, OrdinaryDiffEq, StochasticDiffEq, DiffEqJump\r\n@parameters β γ t\r\n@variables S(t) I(t) R(t)\r\n\r\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\r\n       Reaction(γ, [I], [R])]\r\nrs  = ReactionSystem(rxs, t, [S,I,R], [β,γ])\r\n\r\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\r\nparammap = [β => 1/10000, γ => 0.01]\r\ntspan    = (0.0, 250.0)\r\n\r\n# solve as ODEs\r\nodesys = convert(ODESystem, rs)\r\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\r\nsol = solve(oprob, Tsit5())\r\n\r\n# solve as SDEs\r\nsdesys = convert(SDESystem, rs)\r\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\r\nsol = solve(sprob, EM(), dt=.01)\r\n\r\n# solve as jump process\r\njumpsys = convert(JumpSystem, rs)\r\nu₀map    = [S => 999, I => 1, R => 0]\r\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\r\njprob = JumpProblem(jumpsys, dprob, Direct())\r\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"systems/ReactionSystem/#System-Constructors-1","page":"ReactionSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Reaction\r\nReactionSystem","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.Reaction","page":"ReactionSystem","title":"ModelingToolkit.Reaction","text":"struct Reaction{S, T<:Number}\n\nOne chemical reaction.\n\nFields\n\nrate\nThe rate function (excluding mass action terms).\nsubstrates\nReaction substrates.\nproducts\nReaction products.\nsubstoich\nThe stoichiometric coefficients of the reactants.\nprodstoich\nThe stoichiometric coefficients of the products.\nnetstoich\nThe net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate\nfalse (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nExamples\n\nusing ModelingToolkit\n@parameters t k[1:20]\n@variables A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#ModelingToolkit.ReactionSystem","page":"ReactionSystem","title":"ModelingToolkit.ReactionSystem","text":"struct ReactionSystem <: ModelingToolkit.AbstractSystem\n\nA system of chemical reactions.\n\nFields\n\neqs\nThe reactions defining the system.\niv\nIndependent variable (usually time).\nstates\nDependent (state) variables representing amount of each species.\nps\nParameter variables.\nobserved\nname\nThe name of the system\nsystems\nsystems: The internal systems\n\nExample\n\nContinuing from the example in the Reaction definition:\n\nrs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\n\n\n\n\n","category":"type"},{"location":"systems/ReactionSystem/#Composition-and-Accessor-Functions-1","page":"ReactionSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"get_eqs(sys) or equations(sys): The reactions that define the system.\nget_states(sys) or states(sys): The set of chemical species in the system.\nget_ps(sys) or parameters(sys): The parameters of the system.\nindependent_variable(sys): The independent variable of the reaction system, usually time.","category":"page"},{"location":"systems/ReactionSystem/#Query-Functions-1","page":"ReactionSystem","title":"Query Functions","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"oderatelaw\r\njumpratelaw\r\nismassaction","category":"page"},{"location":"systems/ReactionSystem/#ModelingToolkit.oderatelaw","page":"ReactionSystem","title":"ModelingToolkit.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the rate   law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling factor is   ignored.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#ModelingToolkit.jumpratelaw","page":"ReactionSystem","title":"ModelingToolkit.jumpratelaw","text":"jumpratelaw(rx; rxvars=get_variables(rx.rate), combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nrxvars should give the Variables, i.e. species and parameters, the rate depends on.\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#ModelingToolkit.ismassaction","page":"ReactionSystem","title":"ModelingToolkit.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = any(var -> isequal(get_iv(rs),var), rxvars),\n                              stateset = Set(states(rs)))\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on the independent variable.\nOptional: stateset, set of states which if the rxvars are within mean rx is non-mass action.\n\n\n\n\n\n","category":"function"},{"location":"systems/ReactionSystem/#Transformations-1","page":"ReactionSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ReactionSystem/#","page":"ReactionSystem","title":"ReactionSystem","text":"Base.convert","category":"page"},{"location":"systems/ReactionSystem/#Base.convert","page":"ReactionSystem","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ODESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an NonlinearSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\nnoise_scaling=nothing::Union{Vector{Operation},Operation,Nothing} allows for linear\n\nscaling of the noise in the chemical Langevin equations. If nothing is given, the default value as in Gillespie 2000 is used. Alternatively, an Operation can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the ReactionSystem. Finally, a Vector{Operation} can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/ode_modeling/#Component-Based-Modeling-with-Ordinary-Differential-Equations-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"","category":"section"},{"location":"tutorials/ode_modeling/#Copy-Paste-Example-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Copy-Paste Example","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Here is the complete example, with explanation to follow:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"using ModelingToolkit, OrdinaryDiffEq\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)\r\n\r\neqs = [D(x) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]\r\n\r\nlorenz1 = ODESystem(eqs,name=:lorenz1)\r\nlorenz2 = ODESystem(eqs,name=:lorenz2)\r\n\r\n@variables a\r\n@parameters γ\r\nconnections = [0 ~ lorenz1.x + lorenz2.y + a*γ]\r\nconnected = ODESystem(connections,t,[a],[γ],systems=[lorenz1,lorenz2])\r\n\r\nu0 = [lorenz1.x => 1.0,\r\n      lorenz1.y => 0.0,\r\n      lorenz1.z => 0.0,\r\n      lorenz2.x => 0.0,\r\n      lorenz2.y => 1.0,\r\n      lorenz2.z => 0.0,\r\n      a => 2.0]\r\n\r\np  = [lorenz1.σ => 10.0,\r\n      lorenz1.ρ => 28.0,\r\n      lorenz1.β => 8/3,\r\n      lorenz2.σ => 10.0,\r\n      lorenz2.ρ => 28.0,\r\n      lorenz2.β => 8/3,\r\n      γ => 2.0]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(connected,u0,tspan,p)\r\nsol = solve(prob,Rodas4())\r\n\r\nusing Plots; plot(sol,vars=(a,lorenz1.x,lorenz2.z))","category":"page"},{"location":"tutorials/ode_modeling/#Generating-ODESystems-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Generating ODESystems","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"First let's build an ODE model. To do this we start by defining some variables. In a differential equation system, we need to differentiate between our (dependent) variables and parameters. Therefore, we label them as follows:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"using ModelingToolkit\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Then we build the system:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"eqs = [D(x) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Each operation builds an Term type, and thus eqs is an array of Term and Syms (possibly wrapped in Num). This holds a tree of the full system that can be analyzed by other programs. We can turn this into a ODESystem via:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"sys = ODESystem(eqs)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"This ODESystem can then be used to generate an ODEProblem by supplying the constructor with a map from the states of the system to their initial condition values and from the parameters of the system to their values. For example:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"u0 = [x => 1.0\r\n      y => 0.0\r\n      z => 0.0]\r\n\r\np  = [σ => 10.0\r\n      ρ => 28.0\r\n      β => 8/3]\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(sys,u0,tspan,p;jac=true,sparse=true)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Note that the additional jac=true tells the system to symbolically generate an optimized Jacobian function to enhance the differential equation solvers, and sparse tells it to build the ODEProblem with all of the enhancements setup for sparse Jacobians.","category":"page"},{"location":"tutorials/ode_modeling/#Building-Component-Based-Models-1","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Building Component-Based Models","text":"","category":"section"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Now let's use ModelingToolkit to start building component-based models. Component-based models are compositions between submodels. This allows one to keep independently generated libraries of components intact and use them as the building blocks to construct more complicated models.","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Let's define two interacting Lorenz equations. To do this, we will build two ODESystems from the equations we used in the first part:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"lorenz1 = ODESystem(eqs,name=:lorenz1)\r\nlorenz2 = ODESystem(eqs,name=:lorenz2)","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"Now let's define an interconnection between these ODE systems. Here we will define a new variable α which is defined by the interplay between these two models:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"@variables a(t)\r\n@parameters γ\r\nconnections = [0 ~ lorenz1.x + lorenz2.y + a*γ]\r\nconnected = ODESystem(connections,t,[a],[γ],systems=[lorenz1,lorenz2])","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"This ODESystem thus connects the two Lorenz systems and defines the dynamics of α according to the continuous algebraic equation, thus this is now a differential-algebraic equation (DAE) of 7 variables. We can then define the resulting ODEProblem and send it over to DifferentialEquations.jl:","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"u0 = [lorenz1.x => 1.0,\r\n      lorenz1.y => 0.0,\r\n      lorenz1.z => 0.0,\r\n      lorenz2.x => 0.0,\r\n      lorenz2.y => 1.0,\r\n      lorenz2.z => 0.0,\r\n      a => 2.0]\r\n\r\np  = [lorenz1.σ => 10.0,\r\n      lorenz1.ρ => 28.0,\r\n      lorenz1.β => 8/3,\r\n      lorenz2.σ => 10.0,\r\n      lorenz2.ρ => 28.0,\r\n      lorenz2.β => 8/3,\r\n      γ => 2.0]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(connected,u0,tspan,p)\r\nsol = solve(prob,Rodas4())\r\n\r\nusing Plots; plot(sol,vars=(a,lorenz1.x,lorenz2.z))","category":"page"},{"location":"tutorials/ode_modeling/#","page":"Component-Based Modeling with Ordinary Differential Equations","title":"Component-Based Modeling with Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"systems/NonlinearSystem/#NonlinearSystem-1","page":"NonlinearSystem","title":"NonlinearSystem","text":"","category":"section"},{"location":"systems/NonlinearSystem/#System-Constructors-1","page":"NonlinearSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearSystem","category":"page"},{"location":"systems/NonlinearSystem/#ModelingToolkit.NonlinearSystem","page":"NonlinearSystem","title":"ModelingToolkit.NonlinearSystem","text":"struct NonlinearSystem <: ModelingToolkit.AbstractSystem\n\nA nonlinear system of equations.\n\nFields\n\neqs\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nobserved\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nstructure\nstructure: structural information of the system\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\nns = NonlinearSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/NonlinearSystem/#Composition-and-Accessor-Functions-1","page":"NonlinearSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"get_eqs(sys) or equations(sys): The equations that define the nonlinear system.\nget_states(sys) or states(sys): The set of states in the nonlinear system.\nget_ps(sys) or parameters(sys): The parameters of the nonlinear system.","category":"page"},{"location":"systems/NonlinearSystem/#Transformations-1","page":"NonlinearSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/NonlinearSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"NonlinearSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"calculate_jacobian\r\ngenerate_jacobian\r\njacobian_sparsity","category":"page"},{"location":"systems/NonlinearSystem/#Problem-Constructors-1","page":"NonlinearSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/NonlinearSystem/#","page":"NonlinearSystem","title":"NonlinearSystem","text":"NonlinearProblem","category":"page"},{"location":"systems/NonlinearSystem/#SciMLBase.NonlinearProblem","page":"NonlinearSystem","title":"SciMLBase.NonlinearProblem","text":"function DiffEqBase.NonlinearProblem{iip}(sys::NonlinearSystem,u0map,\n                                          parammap=DiffEqBase.NullParameters();\n                                          jac = false, sparse=false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an NonlinearProblem from a NonlinearSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/ControlSystem/#ControlSystem-1","page":"ControlSystem","title":"ControlSystem","text":"","category":"section"},{"location":"systems/ControlSystem/#System-Constructors-1","page":"ControlSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"ControlSystem","category":"page"},{"location":"systems/ControlSystem/#ModelingToolkit.ControlSystem","page":"ControlSystem","title":"ModelingToolkit.ControlSystem","text":"struct ControlSystem <: ModelingToolkit.AbstractControlSystem\n\nA system describing an optimal control problem. This contains a loss function and ordinary differential equations with control variables that describe the dynamics.\n\nFields\n\nloss\nThe Loss function\neqs\nThe ODEs defining the system.\niv\nIndependent variable.\nstates\nDependent (state) variables.\ncontrols\nControl variables.\nps\nParameter variables.\nobserved\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@variables t x(t) v(t) u(t)\nD = Differential(t)\n\nloss = (4-x)^2 + 2v^2 + u^2\neqs = [\n    D(x) ~ v\n    D(v) ~ u^3\n]\n\nsys = ControlSystem(loss,eqs,t,[x,v],[u],[])\n\n\n\n\n\n","category":"type"},{"location":"systems/ControlSystem/#Composition-and-Accessor-Functions-1","page":"ControlSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"get_eqs(sys or equations(sys): The equations that define the system.\nget_states(sys) or states(sys): The set of states in the system.\nget_ps(sys) or parameters(sys): The parameters of the system.\nget_controls(sys) or controls(sys): The control variables of the system","category":"page"},{"location":"systems/ControlSystem/#Transformations-1","page":"ControlSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ControlSystem/#","page":"ControlSystem","title":"ControlSystem","text":"runge_kutta_discretize","category":"page"},{"location":"systems/ControlSystem/#ModelingToolkit.runge_kutta_discretize","page":"ControlSystem","title":"ModelingToolkit.runge_kutta_discretize","text":"runge_kutta_discretize(sys::ControlSystem,dt,tspan;\n                       tab = ModelingToolkit.constructRadauIIA5())\n\nTransforms a nonlinear optimal control problem into a constrained OptimizationProblem according to a Runge-Kutta tableau that describes a collocation method. Requires a fixed dt over a given timespan. Defaults to using the 5th order RadauIIA tableau, and altnerative tableaus can be specified using the SciML tableau style.\n\n\n\n\n\n","category":"function"},{"location":"basics/Composition/#[Composing-Models-and-Building-Reusable-Components](@ref-components)-1","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"","category":"section"},{"location":"systems/SDESystem/#SDESystem-1","page":"SDESystem","title":"SDESystem","text":"","category":"section"},{"location":"systems/SDESystem/#System-Constructors-1","page":"SDESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDESystem","category":"page"},{"location":"systems/SDESystem/#ModelingToolkit.SDESystem","page":"SDESystem","title":"ModelingToolkit.SDESystem","text":"struct SDESystem <: ModelingToolkit.AbstractODESystem\n\nA system of stochastic differential equations.\n\nFields\n\neqs\nThe expressions defining the drift term.\nnoiseeqs\nThe expressions defining the diffusion term.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\nobserved\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nSystems: the internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nnoiseeqs = [0.1*x,\n            0.1*y,\n            0.1*z]\n\nde = SDESystem(eqs,noiseeqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#Composition-and-Accessor-Functions-1","page":"SDESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"get_eqs(sys) or equations(sys): The equations that define the SDE.\nget_states(sys) or states(sys): The set of states in the SDE.\nget_ps(sys)s or parameters(sys): The parameters of the SDE.\nindependent_variable(sys): The independent variable of the SDE.","category":"page"},{"location":"systems/SDESystem/#Transformations-1","page":"SDESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/SDESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"SDESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W\r\njacobian_sparsity","category":"page"},{"location":"systems/SDESystem/#Problem-Constructors-1","page":"SDESystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/SDESystem/#","page":"SDESystem","title":"SDESystem","text":"SDEFunction\r\nSDEProblem","category":"page"},{"location":"systems/SDESystem/#SciMLBase.SDEFunction","page":"SDESystem","title":"SciMLBase.SDEFunction","text":"function DiffEqBase.SDEFunction{iip}(sys::SDESystem, dvs = sys.states, ps = sys.ps;\n                                     version = nothing, tgrad=false, sparse = false,\n                                     jac = false, Wfact = false, kwargs...) where {iip}\n\nCreate an SDEFunction from the SDESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/SDESystem/#SciMLBase.SDEProblem","page":"SDESystem","title":"SciMLBase.SDEProblem","text":"function DiffEqBase.SDEProblem{iip}(sys::SDESystem,u0map,tspan,p=parammap;\n                                    version = nothing, tgrad=false,\n                                    jac = false, Wfact = false,\n                                    checkbounds = false, sparse = false,\n                                    sparsenoise = sparse,\n                                    skipzeros = true, fillzeros = true,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...)\n\nGenerates an SDEProblem from an SDESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"systems/PDESystem/#PDESystem-1","page":"PDESystem","title":"PDESystem","text":"","category":"section"},{"location":"systems/PDESystem/#","page":"PDESystem","title":"PDESystem","text":"PDESystem is still a work in progress.","category":"page"},{"location":"tutorials/modelingtoolkitize/#Symbolic-Extensions-to-ODEProblem-via-Modelingtoolkitize-1","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"For some DEProblem types, automatic tracing functionality is already included via the modelingtoolkitize function. Take, for example, the Robertson ODE defined as an ODEProblem for DifferentialEquations.jl:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"using DifferentialEquations\r\nfunction rober(du,u,p,t)\r\n  y₁,y₂,y₃ = u\r\n  k₁,k₂,k₃ = p\r\n  du[1] = -k₁*y₁+k₃*y₂*y₃\r\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\r\n  du[3] =  k₂*y₂^2\r\n  nothing\r\nend\r\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"If we want to get a symbolic representation, we can simply call modelingtoolkitize on the prob, which will return an ODESystem:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"sys = modelingtoolkitize(prob)","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"Using this, we can symbolically build the Jacobian and then rebuild the ODEProblem:","category":"page"},{"location":"tutorials/modelingtoolkitize/#","page":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","title":"Symbolic Extensions to ODEProblem via Modelingtoolkitize","text":"jac = eval(ModelingToolkit.generate_jacobian(sys)[2])\r\nf = ODEFunction(rober, jac=jac)\r\nprob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))","category":"page"},{"location":"systems/OptimizationSystem/#OptimizationSystem-1","page":"OptimizationSystem","title":"OptimizationSystem","text":"","category":"section"},{"location":"systems/OptimizationSystem/#System-Constructors-1","page":"OptimizationSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationSystem","category":"page"},{"location":"systems/OptimizationSystem/#ModelingToolkit.OptimizationSystem","page":"OptimizationSystem","title":"ModelingToolkit.OptimizationSystem","text":"struct OptimizationSystem <: ModelingToolkit.AbstractSystem\n\nA scalar equation for optimization.\n\nFields\n\nop\nVector of equations defining the system.\nstates\nUnknown variables.\nps\nParameters.\nobserved\nequality_constraints\ninequality_constraints\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExamples\n\n@variables x y z\n@parameters σ ρ β\n\nop = σ*(y-x) + x*(ρ-z)-y + x*y - β*z\nos = OptimizationSystem(eqs, [x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/OptimizationSystem/#Composition-and-Accessor-Functions-1","page":"OptimizationSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"get_eqs(sys) or equations(sys): The equation to be minimized.\nget_states(sys) or states(sys): The set of states for the optimization.\nget_ps(sys) or parameters(sys): The parameters for the optimization.","category":"page"},{"location":"systems/OptimizationSystem/#Transformations-1","page":"OptimizationSystem","title":"Transformations","text":"","category":"section"},{"location":"systems/OptimizationSystem/#Applicable-Calculation-and-Generation-Functions-1","page":"OptimizationSystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"calculate_gradient\r\ncalculate_hessian\r\ngenerate_gradient\r\ngenerate_hessian\r\nhessian_sparsity","category":"page"},{"location":"systems/OptimizationSystem/#Problem-Constructors-1","page":"OptimizationSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/OptimizationSystem/#","page":"OptimizationSystem","title":"OptimizationSystem","text":"OptimizationProblem","category":"page"},{"location":"systems/OptimizationSystem/#SciMLBase.OptimizationProblem","page":"OptimizationSystem","title":"SciMLBase.OptimizationProblem","text":"function DiffEqBase.OptimizationProblem{iip}(sys::OptimizationSystem,\n                                          parammap=DiffEqBase.NullParameters();\n                                          u0=nothing, lb=nothing, ub=nothing,\n                                          grad = false,\n                                          hess = false, sparse = false,\n                                          checkbounds = false,\n                                          linenumbers = true, parallel=SerialForm(),\n                                          kwargs...) where iip\n\nGenerates an OptimizationProblem from an OptimizationSystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/higher_order/#Automatic-Transformation-of-Nth-Order-ODEs-to-1st-Order-ODEs-1","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"","category":"section"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"ModelingToolkit has a system for transformations of mathematical systems. These transformations allow for symbolically changing the representation of the model to problems that are easier to numerically solve. One simple to demonstrate transformation is the ode_order_lowering transformation that sends an Nth order ODE to a 1st order ODE.","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"To see this, let's define a second order riff on the Lorenz equations. We utilize the derivative operator twice here to define the second order:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"using ModelingToolkit, OrdinaryDiffEq\r\n\r\n@parameters t σ ρ β\r\n@variables x(t) y(t) z(t)\r\nD = Differential(t)\r\n\r\neqs = [D(D(x)) ~ σ*(y-x),\r\n       D(y) ~ x*(ρ-z)-y,\r\n       D(z) ~ x*y - β*z]\r\n\r\nsys = ODESystem(eqs)","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Note that we could've used an alternative syntax for 2nd order, i.e. D = Differential(t)^2 and then E(x) would be the second derivative, and this syntax extends to N-th order. Also, we can use * or ∘ to compose Differentials, like Differential(t) * Differential(x).","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now let's transform this into the ODESystem of first order components. We do this by simply calling ode_order_lowering:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"sys = ode_order_lowering(sys)","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now we can directly numerically solve the lowered system. Note that, following the original problem, the solution requires knowing the initial condition for x', and thus we include that in our input specification:","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"u0 = [D(x) => 2.0,\r\n      x => 1.0,\r\n      y => 0.0,\r\n      z => 0.0]\r\n\r\np  = [σ => 28.0,\r\n      ρ => 10.0,\r\n      β => 8/3]\r\n\r\ntspan = (0.0,100.0)\r\nprob = ODEProblem(sys,u0,tspan,p,jac=true)\r\nsol = solve(prob,Tsit5())\r\nusing Plots; plot(sol,vars=(x,y))","category":"page"},{"location":"tutorials/higher_order/#","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"(Image: Lorenz2)","category":"page"},{"location":"systems/ODESystem/#ODESystem-1","page":"ODESystem","title":"ODESystem","text":"","category":"section"},{"location":"systems/ODESystem/#System-Constructors-1","page":"ODESystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODESystem","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ODESystem","page":"ODESystem","title":"ModelingToolkit.ODESystem","text":"struct ODESystem <: ModelingToolkit.AbstractODESystem\n\nA system of ordinary differential equations.\n\nFields\n\neqs\nThe ODEs defining the system.\niv\nIndependent variable.\nstates\nDependent (state) variables.\nps\nParameter variables.\nobserved\ntgrad\nTime-derivative matrix. Note: this field will not be defined until calculate_tgrad is called on the system.\n\njac\nJacobian matrix. Note: this field will not be defined until calculate_jacobian is called on the system.\n\nWfact\nWfact matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nWfact_t\nWfact_t matrix. Note: this field will not be defined until generate_factorized_W is called on the system.\n\nname\nName: the name of the system\n\nsystems\nsystems: The internal systems. These are required to have unique names.\n\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nstructure\nstructure: structural information of the system\n\nExample\n\nusing ModelingToolkit\n\n@parameters t σ ρ β\n@variables x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(x) ~ σ*(y-x),\n       D(y) ~ x*(ρ-z)-y,\n       D(z) ~ x*y - β*z]\n\nde = ODESystem(eqs,t,[x,y,z],[σ,ρ,β])\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#Composition-and-Accessor-Functions-1","page":"ODESystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"get_eqs(sys) or equations(sys): The equations that define the ODE.\nget_states(sys) or states(sys): The set of states in the ODE.\nget_ps(sys) or parameters(sys): The parameters of the ODE.\nindependent_variable(sys): The independent variable of the ODE.","category":"page"},{"location":"systems/ODESystem/#Transformations-1","page":"ODESystem","title":"Transformations","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ode_order_lowering\r\nliouville_transform","category":"page"},{"location":"systems/ODESystem/#ModelingToolkit.ode_order_lowering","page":"ODESystem","title":"ModelingToolkit.ode_order_lowering","text":"ode_order_lowering(sys::ODESystem) -> ODESystem\n\n\nTakes a Nth order ODESystem and returns a new ODESystem written in first order form by defining new variables which represent the N-1 derivatives.\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#ModelingToolkit.liouville_transform","page":"ODESystem","title":"ModelingToolkit.liouville_transform","text":"liouville_transform(sys::Any) -> ODESystem\n\n\nGenerates the Liouville transformed set of ODEs, which is the original ODE system with a new variable trJ appended, corresponding to the -tr(Jacobian). This variable is used for properties like uncertainty propagation from a given initial distribution density.\n\nFor example, if u=p*u and p follows a probability distribution f(p), then the probability density of a future value with a given choice of p is computed by setting the inital trJ = f(p), and the final value of trJ is the probability of u(t).\n\nExample:\n\nusing ModelingToolkit, OrdinaryDiffEq, Test\n\n@parameters t α β γ δ\n@variables x(t) y(t)\nD = Differential(t)\n\neqs = [D(x) ~ α*x - β*x*y,\n       D(y) ~ -δ*y + γ*x*y]\n\nsys = ODESystem(eqs)\nsys2 = liouville_transform(sys)\n@variables trJ\n\nu0 = [x => 1.0,\n      y => 1.0,\n      trJ => 1.0]\n\nprob = ODEProblem(sys2,u0,tspan,p)\nsol = solve(prob,Tsit5())\n\nWhere sol[3,:] is the evolution of trJ over time.\n\nSources:\n\nProbabilistic Robustness Analysis of F-16 Controller Performance: An Optimal Transport Approach\n\nAbhishek Halder, Kooktae Lee, and Raktim Bhattacharya https://abhishekhalder.bitbucket.io/F16ACC2013Final.pdf\n\n\n\n\n\n","category":"function"},{"location":"systems/ODESystem/#Applicable-Calculation-and-Generation-Functions-1","page":"ODESystem","title":"Applicable Calculation and Generation Functions","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"calculate_jacobian\r\ncalculate_tgrad\r\ncalculate_factorized_W\r\ngenerate_jacobian\r\ngenerate_tgrad\r\ngenerate_factorized_W\r\njacobian_sparsity","category":"page"},{"location":"systems/ODESystem/#Problem-Constructors-1","page":"ODESystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/ODESystem/#","page":"ODESystem","title":"ODESystem","text":"ODEFunction\r\nODEProblem","category":"page"},{"location":"systems/ODESystem/#SciMLBase.ODEFunction","page":"ODESystem","title":"SciMLBase.ODEFunction","text":"function DiffEqBase.ODEFunction{iip}(sys::AbstractODESystem, dvs = states(sys),\n                                     ps = parameters(sys);\n                                     version = nothing, tgrad=false,\n                                     jac = false,\n                                     sparse = false,\n                                     kwargs...) where {iip}\n\nCreate an ODEFunction from the ODESystem. The arguments dvs and ps are used to set the order of the dependent variable and parameter vectors, respectively.\n\n\n\n\n\n","category":"type"},{"location":"systems/ODESystem/#SciMLBase.ODEProblem","page":"ODESystem","title":"SciMLBase.ODEProblem","text":"function DiffEqBase.ODEProblem{iip}(sys::AbstractODESystem,u0map,tspan,\n                                    parammap=DiffEqBase.NullParameters();\n                                    version = nothing, tgrad=false,\n                                    jac = false,\n                                    checkbounds = false, sparse = false,\n                                    simplify=false,\n                                    linenumbers = true, parallel=SerialForm(),\n                                    kwargs...) where iip\n\nGenerates an ODEProblem from an ODESystem and allows for automatically symbolically calculating numerical enhancements.\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Dependency-Graphs-1","page":"Dependency Graphs","title":"Dependency Graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Types-1","page":"Dependency Graphs","title":"Types","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"BipartiteGraph","category":"page"},{"location":"basics/DependencyGraphs/#ModelingToolkit.BipartiteGraphs.BipartiteGraph","page":"Dependency Graphs","title":"ModelingToolkit.BipartiteGraphs.BipartiteGraph","text":"mutable struct BipartiteGraph{I<:Integer, M} <: LightGraphs.AbstractGraph{I<:Integer}\n\nA bipartite graph representation between two, possibly distinct, sets of vertices (source and dependencies). Maps source vertices, labelled 1:N₁, to vertices on which they depend (labelled 1:N₂).\n\nFields\n\nne\nfadjlist\nbadjlist\nmetadata\n\nExample\n\nusing ModelingToolkit\n\nne = 4\nsrcverts = 1:4\ndepverts = 1:2\n\n# six source vertices\nfadjlist = [[1],[1],[2],[2],[1],[1,2]]\n\n# two vertices they depend on\nbadjlist = [[1,2,5,6],[3,4,6]]\n\nbg = BipartiteGraph(7, fadjlist, badjlist)\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Utility-functions-for-BiPartiteGraphs-1","page":"Dependency Graphs","title":"Utility functions for BiPartiteGraphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"Base.isequal","category":"page"},{"location":"basics/DependencyGraphs/#Base.isequal","page":"Dependency Graphs","title":"Base.isequal","text":"Base.isequal(bg1::BipartiteGraph{T}, bg2::BipartiteGraph{T}) where {T<:Integer}\n\nTest whether two BipartiteGraphs are equal.\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#Functions-for-calculating-dependency-graphs-1","page":"Dependency Graphs","title":"Functions for calculating dependency graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#","page":"Dependency Graphs","title":"Dependency Graphs","text":"equation_dependencies\nasgraph\nvariable_dependencies\nasdigraph\neqeq_dependencies\nvarvar_dependencies","category":"page"},{"location":"basics/DependencyGraphs/#ModelingToolkit.equation_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.equation_dependencies","text":"equation_dependencies(sys::AbstractSystem; variables=states(sys))\n\nGiven an AbstractSystem calculate for each equation the variables it depends on.\n\nNotes:\n\nVariables that are not in variables are filtered out.\nget_variables! is used to determine the variables within a given equation.\nreturns a Vector{Vector{Variable}}() mapping the index of an equation to the variables it depends on.\n\nExample:\n\nusing ModelingToolkit\n@parameters β γ κ η t\n@variables S(t) I(t) R(t)\n\n# use a reaction system to easily generate ODE and jump systems\nrxs = [Reaction(β, [S,I], [I], [1,1], [2]),\n       Reaction(γ, [I], [R]),\n       Reaction(κ+η, [R], [S])]\nrs = ReactionSystem(rxs, t, [S,I,R], [β,γ,κ,η])\n\n# ODEs:\nodesys = convert(ODESystem, rs)\n\n# dependency of each ODE on state variables\nequation_dependencies(odesys)\n\n# dependency of each ODE on parameters\nequation_dependencies(odesys, variables=parameters(odesys))\n\n# Jumps\njumpsys = convert(JumpSystem, rs)\n\n# dependency of each jump rate function on state variables\nequation_dependencies(jumpsys)\n\n# dependency of each jump rate function on parameters\nequation_dependencies(jumpsys, variables=parameters(jumpsys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asgraph","page":"Dependency Graphs","title":"ModelingToolkit.asgraph","text":"asgraph(eqdeps, vtois)\n\nConvert a collection of equation dependencies, for example as returned by equation_dependencies, to a BipartiteGraph.\n\nNotes:\n\nvtois should provide a Dict like mapping from each Variable dependency in eqdeps to the integer idx of the variable to use in the graph.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(equation_dependencies(odesys), Dict(s => i for (i,s) in enumerate(states(odesys))))\n\n\n\n\n\nasgraph(sys::AbstractSystem; variables=states(sys),\n                                      variablestoids=Dict(convert(Variable, v) => i for (i,v) in enumerate(variables)))\n\nConvert an AbstractSystem to a BipartiteGraph mapping the index of equations to the indices of variables they depend on.\n\nNotes:\n\nDefaults for kwargs creating a mapping from equations(sys) to states(sys) they depend on.\nvariables should provide the list of variables to use for generating the dependency graph.\nvariablestoids should provide Dict like mapping from a Variable to its Int index within variables.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(odesys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.variable_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.variable_dependencies","text":"variable_dependencies(sys::AbstractSystem; variables=states(sys), variablestoids=nothing)\n\nFor each variable determine the equations that modify it and return as a BipartiteGraph.\n\nNotes:\n\nDependencies are returned as a BipartiteGraph mapping variable indices to the indices of equations that modify them.\nvariables denotes the list of variables to determine dependencies for.\nvariablestoids denotes a Dict mapping Variables to their Int index in variables.\n\nExample: Continuing the example of equation_dependencies\n\nvariable_dependencies(odesys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asdigraph","page":"Dependency Graphs","title":"ModelingToolkit.asdigraph","text":"asdigraph(g::BipartiteGraph, sys::AbstractSystem; variables = states(sys), equationsfirst = true)\n\nConvert a BipartiteGraph to a LightGraph.SimpleDiGraph.\n\nNotes:\n\nThe resulting SimpleDiGraph unifies the two sets of vertices (equations and then states in the case it comes from asgraph), producing one ordered set of integer vertices (SimpleDiGraph does not support two distinct collections of vertices so they must be merged).\nvariables gives the variables that g is associated with (usually the states of a system).\nequationsfirst (default is true) gives whether the BipartiteGraph gives a mapping from equations to variables they depend on (true), as calculated by asgraph, or whether it gives a mapping from variables to the equations that modify them, as calculated by variable_dependencies.\n\nExample: Continuing the example in asgraph\n\ndg = asdigraph(digr)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.eqeq_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.eqeq_dependencies","text":"eqeq_dependencies(eqdeps::BipartiteGraph{T}, vardeps::BipartiteGraph{T}) where {T <: Integer}\n\nCalculate a LightGraph.SimpleDiGraph that maps each equation to equations they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from an equation to the equations that modify variables it depends on.\nThe badjlist of the SimpleDiGraph maps from an equation to equations that depend on variables it modifies.\n\nExample: Continuing the example of equation_dependencies\n\neqeqdep = eqeq_dependencies(asgraph(odesys), variable_dependencies(odesys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.varvar_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.varvar_dependencies","text":"varvar_dependencies(eqdeps::BipartiteGraph{T}, vardeps::BipartiteGraph{T}) where {T <: Integer} = eqeq_dependencies(vardeps, eqdeps)\n\nCalculate a LightGraph.SimpleDiGraph that maps each variable to variables they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from a variable to the variables that depend on it.\nThe badjlist of the SimpleDiGraph maps from a variable to variables on which it depends.\n\nExample: Continuing the example of equation_dependencies\n\nvarvardep = varvar_dependencies(asgraph(odesys), variable_dependencies(odesys))\n\n\n\n\n\n","category":"function"},{"location":"tutorials/nonlinear/#Solving-Nonlinear-Systems-with-NLsolve-1","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"","category":"section"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"In this example we will go one step deeper and showcase the direct function generation capabilities in ModelingToolkit.jl to build nonlinear systems. Let's say we wanted to solve for the steady state of the previous ODE. This is the nonlinear system defined by where the derivatives are zero. We use (unknown) variables for our nonlinear system.","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"using ModelingToolkit\r\n\r\n@variables x y z\r\n@parameters σ ρ β\r\n\r\n# Define a nonlinear system\r\neqs = [0 ~ σ*(y-x),\r\n       0 ~ x*(ρ-z)-y,\r\n       0 ~ x*y - β*z]\r\nns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\r\nnlsys_func = generate_function(ns)[2] # second is the inplace version","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which generates:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"(var\"##MTIIPVar#405\", u, p)->begin\r\n        @inbounds begin\r\n                @inbounds begin\r\n                        let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                            var\"##MTIIPVar#405\"[1] = (*)(σ, (-)(y, x))\r\n                            var\"##MTIIPVar#405\"[2] = (-)((*)(x, (-)(ρ, z)), y)\r\n                            var\"##MTIIPVar#405\"[3] = (-)((*)(x, y), (*)(β, z))\r\n                        end\r\n                    end\r\n            end\r\n        nothing\r\n    end","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"We can use this to build a nonlinear function for use with NLsolve.jl:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"f = eval(nlsys_func)\r\ndu = zeros(3); u = ones(3)\r\nparams = (10.0,26.0,2.33)\r\nf(du,u,params)\r\ndu\r\n\r\n#=\r\n3-element Array{Float64,1}:\r\n  0.0\r\n 24.0\r\n -1.33\r\n =#","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"We can similarly ask to generate the in-place Jacobian function:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"j_func = generate_jacobian(ns)[2] # second is in-place\r\nj! = eval(j_func)","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which gives:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":":((var\"##MTIIPVar#582\", u, p)->begin\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:70 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =#\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:71 =# @inbounds begin\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:72 =#\r\n                  #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =# @inbounds begin\r\n                          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:53 =#\r\n                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])\r\n                              var\"##MTIIPVar#582\"[1] = (*)(σ, -1)\r\n                              var\"##MTIIPVar#582\"[2] = (-)(ρ, z)\r\n                              var\"##MTIIPVar#582\"[3] = y\r\n                              var\"##MTIIPVar#582\"[4] = σ\r\n                              var\"##MTIIPVar#582\"[5] = -1\r\n                              var\"##MTIIPVar#582\"[6] = x\r\n                              var\"##MTIIPVar#582\"[7] = 0\r\n                              var\"##MTIIPVar#582\"[8] = (*)(x, -1)\r\n                              var\"##MTIIPVar#582\"[9] = (*)(-1, β)\r\n                          end\r\n                      end\r\n              end\r\n          #= C:\\Users\\accou\\.julia\\dev\\ModelingToolkit\\src\\utils.jl:74 =#\r\n          nothing\r\n      end)","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"Now, we can call nlsolve by enclosing our parameters into the functions:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"using NLsolve\r\nnlsolve((out, x) -> f(out, x, params), (out, x) -> j!(out, x, params), ones(3))","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"If one would like the generated function to be a Julia function instead of an expression, and allow this function to be used from within the same world-age, one simply needs to pass Val{false} to tell it to generate the function, i.e.:","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"nlsys_func = generate_function(ns, [x,y,z], [σ,ρ,β], expression=Val{false})[2]","category":"page"},{"location":"tutorials/nonlinear/#","page":"Solving Nonlinear Systems with NLsolve","title":"Solving Nonlinear Systems with NLsolve","text":"which uses GeneralizedGenerated.jl to build the same world-age function on the fly without eval.","category":"page"},{"location":"systems/JumpSystem/#JumpSystem-1","page":"JumpSystem","title":"JumpSystem","text":"","category":"section"},{"location":"systems/JumpSystem/#System-Constructors-1","page":"JumpSystem","title":"System Constructors","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"JumpSystem","category":"page"},{"location":"systems/JumpSystem/#ModelingToolkit.JumpSystem","page":"JumpSystem","title":"ModelingToolkit.JumpSystem","text":"struct JumpSystem{U<:RecursiveArrayTools.ArrayPartition} <: ModelingToolkit.AbstractSystem\n\nA system of jump processes.\n\nFields\n\neqs\nThe jumps of the system. Allowable types are ConstantRateJump, VariableRateJump, MassActionJump.\n\niv\nThe independent variable, usually time.\nstates\nThe dependent variables, representing the state of the system.\nps\nThe parameters of the system.\nobserved\nname\nThe name of the system.\nsystems\nThe internal systems.\ndefault_u0\ndefault_u0: The default initial conditions to use when initial conditions are not supplied in ODEProblem.\n\ndefault_p\ndefault_p: The default parameters to use when parameters are not supplied in ODEProblem.\n\nExample\n\nusing ModelingToolkit\n\n@parameters β γ t\n@variables S I R\nrate₁   = β*S*I\naffect₁ = [S ~ S - 1, I ~ I + 1]\nrate₂   = γ*I\naffect₂ = [I ~ I - 1, R ~ R + 1]\nj₁      = ConstantRateJump(rate₁,affect₁)\nj₂      = ConstantRateJump(rate₂,affect₂)\nj₃      = MassActionJump(2*β+γ, [R => 1], [S => 1, R => -1])\njs      = JumpSystem([j₁,j₂,j₃], t, [S,I,R], [β,γ])\n\n\n\n\n\n","category":"type"},{"location":"systems/JumpSystem/#Composition-and-Accessor-Functions-1","page":"JumpSystem","title":"Composition and Accessor Functions","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"get_eqs(sys) or equations(sys): The equations that define the jump system.\nget_states(sys) or states(sys): The set of states in the jump system.\nget_ps(sys) or parameters(sys): The parameters of the jump system.\nindependent_variable(sys): The independent variable of the jump system.","category":"page"},{"location":"systems/JumpSystem/#Problem-Constructors-1","page":"JumpSystem","title":"Problem Constructors","text":"","category":"section"},{"location":"systems/JumpSystem/#","page":"JumpSystem","title":"JumpSystem","text":"DiscreteProblem\nJumpProblem","category":"page"},{"location":"systems/JumpSystem/#SciMLBase.DiscreteProblem","page":"JumpSystem","title":"SciMLBase.DiscreteProblem","text":"function DiffEqBase.DiscreteProblem(sys::JumpSystem, u0map, tspan,\n                                    parammap=DiffEqBase.NullParameters; kwargs...)\n\nGenerates a blank DiscreteProblem for a pure jump JumpSystem to utilize as its prob.prob. This is used in the case where there are no ODEs and no SDEs associated with the system.\n\nContinuing the example from the JumpSystem definition:\n\nusing DiffEqBase, DiffEqJump\nu₀map = [S => 999, I => 1, R => 0]\nparammap = [β => .1/1000, γ => .01]\ntspan = (0.0, 250.0)\ndprob = DiscreteProblem(js, u₀map, tspan, parammap)\n\n\n\n\n\n","category":"type"},{"location":"systems/JumpSystem/#DiffEqJump.JumpProblem","page":"JumpSystem","title":"DiffEqJump.JumpProblem","text":"function DiffEqBase.JumpProblem(js::JumpSystem, prob, aggregator; kwargs...)\n\nGenerates a JumpProblem from a JumpSystem.\n\nContinuing the example from the DiscreteProblem definition:\n\njprob = JumpProblem(js, dprob, Direct())\nsol = solve(jprob, SSAStepper())\n\n\n\n\n\n","category":"type"},{"location":"basics/ContextualVariables/#Contextual-Variable-Types-1","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"ModelingToolkit.jl has a system of contextual variable types which allows for helping the system transformation machinery do complex manipulations and automatic detection. The standard variable definition in ModelingToolkit.jl is the @variable which is defined by Symbolics.jl. For example:","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variabes x y(x)","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"This is used for the \"normal\" variable of a given system, like the states of a differential equation or objective function. All of the macros below support the same syntax as @variables.","category":"page"},{"location":"basics/ContextualVariables/#Parameters-1","page":"Contextual Variable Types","title":"Parameters","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"All modeling projects have some form of parameters. @parameters marks a variable as being the parameter of some system, which allows automatic detection algorithms to ignore such variables when attempting to find the states of a system.","category":"page"},{"location":"basics/ContextualVariables/#Flow-Variables-(TODO)-1","page":"Contextual Variable Types","title":"Flow Variables (TODO)","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"In many engineering systems some variables act like \"flows\" while others do not. For example, in circuit models you have current which flows, and the related voltage which does not. Or in thermal models you have heat flows. In these cases, the connect statement enforces conservation of flow between all of the connected components.","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"For example, the following specifies that x is a 2x2 matrix of flow variables:","category":"page"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variables x[1:2,1:2] type=flow","category":"page"},{"location":"basics/ContextualVariables/#Stream-Variables-1","page":"Contextual Variable Types","title":"Stream Variables","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"TODO","category":"page"},{"location":"basics/ContextualVariables/#Brownian-Variables-1","page":"Contextual Variable Types","title":"Brownian Variables","text":"","category":"section"},{"location":"basics/ContextualVariables/#","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"TODO","category":"page"},{"location":"#ModelingToolkit.jl:-High-Performance-Symbolic-Numeric-Equation-Based-Modeling-1","page":"Home","title":"ModelingToolkit.jl: High-Performance Symbolic-Numeric Equation-Based Modeling","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl is a modeling language for high-performance symbolic-numeric computation in scientific computing and scientific machine learning. It then mixes ideas from symbolic computational algebra systems with causal and acausal equation-based modeling frameworks to give an extendable and parallel modeling system. It allows for users to give a high-level description of a model for symbolic preprocessing to analyze and enhance the model. Automatic transformations, such as index reduction, can be applied to the model before solving in order to make it easily handle equations would could not be solved when modeled without symbolic intervention.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install ModelingToolkit.jl, use the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelingToolkit\")","category":"page"},{"location":"#Feature-Summary-1","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl is a symbolic-numeric modeling package. Thus it combines some of the features from symbolic computing packages like SymPy or Mathematica with the ideas of equation-based modeling systems like the causal Simulink and the acausal Modelica. It bridges the gap between many different kinds of equations, allowing one to quickly and easily transform systems of DAEs into optimization problems, or vice-versa, and then simplify and parallelize the resulting expressions before generating code.","category":"page"},{"location":"#Feature-List-1","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Causal and acausal modeling (Simulink/Modelica)\nAutomated model transformation, simplification, and composition\nAutomatic conversion of numerical models into symbolic models\nComposition of models through the components, a lazy connection system, and tools for expanding/flattening\nPervasive parallelism in symbolic computations and generated functions\nTransformations like alias elimination and tearing of nonlinear systems for efficiently numerically handling large-scale systems of equations\nThe ability to use the entire Symbolics.jl Computer Algebra System (CAS) as part of the modeling process.\nImport models from common formats like SBML, CellML, BioNetGen, and more.\nExtendability: the whole system is written in pure Julia, so adding new functions, simplification rules, and model transformations has no barrier.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For information on how to use the Symbolics.jl CAS system that ModelingToolkit.jl is built on, consult the Symbolics.jl documentation","category":"page"},{"location":"#Equation-Types-1","page":"Home","title":"Equation Types","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ordinary differential equations\nStochastic differential equations\nPartial differential equations\nNonlinear systems\nOptimization problems\nContinuous-Time Markov Chains\nChemical Reactions\nOptimal Control","category":"page"},{"location":"#Extension-Libraries-1","page":"Home","title":"Extension Libraries","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Because ModelingToolkit.jl is the core foundation of a equation-based modeling ecosystem, there is a large set of libraries adding features to this system. Below is an incomplete list of extension libraries one may want to be aware of:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"StructuralTransformations.jl: Various transformations of models into structurally better versions for improved numerical simulation\nPantelides algortihm for index reduction of DAEs\nTearing of ODESystems and NonolinearSystems to reduce the numerical cost of handling large implicit systems via Newton methods\nCatalyst.jl: Symbolic representations of chemical reactions\nSymbolically build and represent large systems of chemical reactions\nGenerate code for ODEs, SDEs, continuous-time Markov Chains, and more\nSimulate the models using the SciML ecosystem with O(1) Gillespie methods\nDataDrivenDiffEq.jl: Automatic identification of equations from data\nAutomated construction of ODEs and DAEs from data\nRepresentations of Koopman operators and Dynamic Mode Decomposition (DMD)\nMomentClosure.jl: Automatic transformation of ReactionSystems into deterministic systems\nGenerates ODESystems for the moment closures\nAllows for geometrically-distributed random reaction rates\nReactionMechanismSimulator.jl: simulating and analyzing large chemical reaction mechanisms\nIdeal gas and dilute liquid phases.\nConstant T and P and constant V adiabatic ideal gas reactors.\nConstant T and V dilute liquid reactors.\nDiffusion limited rates. Sensitivity analysis for all reactors.\nFlux diagrams with molecular images (if molecular information is provided).","category":"page"},{"location":"#Model-Import-Formats-1","page":"Home","title":"Model Import Formats","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CellMLToolkit.jl: Import CellML models into ModelingToolkit\nRepository of more than a thousand pre-made models\nFocus on biomedical models in areas such as: Calcium Dynamics, Cardiovascular Circulation, Cell Cycle, Cell Migration, Circadian Rhythms, Electrophysiology, Endocrine, Excitation-Contraction Coupling, Gene Regulation, Hepatology, Immunology, Ion Transport, Mechanical Constitutive Laws, Metabolism, Myofilament Mechanics, Neurobiology, pH Regulation, PKPD, Protein Modules, Signal Transduction, and Synthetic Biology.\nSbmlInterface.jl: Import SBML models into ModelingToolkit\nUses the robust libsbml library for parsing and transforming the SBML\nReactionNetworkImporters.jl: Import various models into ModelingToolkit\nSupports the BioNetGen .net file\nSupports importing networks specified by stoichiometric matrices","category":"page"},{"location":"#Compatible-Numerical-Solvers-1","page":"Home","title":"Compatible Numerical Solvers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All of the symbolic systems have a direct conversion to a numerical system which can then be handled through the SciML interfaces. For example, after building a model and performing symbolic manipulations, an ODESystem can be converted into an ODEProblem to then be solved by a numerical ODE solver. Below is a list of the solver libraries which are the numerical targets of the ModelingToolkit system:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DifferentialEquations.jl\nMulti-package interface of high performance numerical solvers for ODESystem, SDESystem, and JumpSystem\nNonlinearSolve.jl\nHigh performance numerical solving of NonlinearSystem\nGalacticOptim.jl\nMulti-package interface for numerical solving OptimizationSystem\nNeuralPDE.jl\nPhysics-Informed Neural Network (PINN) training on PDESystem\nDiffEqOperators.jl\nAutomated finite difference method (FDM) discretization of PDESystem","category":"page"}]
}
